/* Generated code for Python module 'pylibpd'
 * created by Nuitka version 0.6.1.1
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_pylibpd" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_pylibpd;
PyDictObject *moduledict_pylibpd;

/* The declarations of module constants used, if any. */
static PyObject *const_str_digest_d8498194b4aa4245dad6dd2c71b3dbb9;
static PyObject *const_str_plain_libpd_message;
static PyObject *const_str_plain_builtins;
static PyObject *const_str_plain_get;
static PyObject *const_tuple_str_plain_dir_tuple;
static PyObject *const_tuple_str_plain_dest_str_plain_sym_str_plain_args_tuple;
static PyObject *const_str_plain_ticks;
static PyObject *const_tuple_str_plain_args_str_plain_arg_tuple;
static PyObject *const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple;
static PyObject *const_str_plain_libpd_programchange;
static PyObject *const_str_plain__swig_setattr_nondynamic;
static PyObject *const_str_plain_property;
static PyObject *const_tuple_b13917ad0b5118481f8f4f005491270c_tuple;
static PyObject *const_tuple_str_plain_dest_str_plain_sym_tuple;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_PdManager;
static PyObject *const_str_plain_libpd_unsubscribe;
static PyObject *const_str_plain_inch;
static PyObject *const_str_plain_libpd_symbol;
extern PyObject *const_str_plain_libpd_open_patch;
static PyObject *const_str_digest_e399ba4554180f37de594a6743234f17;
static PyObject *const_str_plain_arg1;
static PyObject *const_str_plain_libpd_set_bang_callback;
static PyObject *const_str_plain_swig_import_helper;
static PyObject *const_str_plain_SwigPyObject;
static PyObject *const_str_digest_44a910c126961a21fb78c77a5e30433a;
static PyObject *const_str_plain_rpartition;
static PyObject *const_str_plain_libpd_set_programchange_callback;
static PyObject *const_tuple_str_plain_arg1_str_plain_arg2_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_inbuf_tuple;
static PyObject *const_str_plain___repr__;
static PyObject *const_tuple_str_plain_dz_tuple;
static PyObject *const_str_plain___libpd_finish_message;
static PyObject *const_str_plain_self;
static PyObject *const_str_plain___process_args;
static PyObject *const_str_plain___libpd_openfile;
extern PyObject *const_str_plain_sys;
static PyObject *const_str_plain_libpd_set_print_callback;
static PyObject *const_str_plain_own;
static PyObject *const_str_plain_libpd_set_message_callback;
static PyObject *const_tuple_str_plain_name_tuple;
static PyObject *const_str_plain_outch;
static PyObject *const_str_plain___builtin__;
static PyObject *const_str_plain_inb;
static PyObject *const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple;
static PyObject *const_str_plain_libpd_sysex;
static PyObject *const_str_plain_close;
static PyObject *const_tuple_str_plain_version_info_tuple;
static PyObject *const_tuple_str_plain_p_tuple;
static PyObject *const_str_plain_process;
static PyObject *const_str_digest_07348ad52202465dc552f2bfab430ac3;
static PyObject *const_str_plain__pylibpd;
static PyObject *const_str_plain_args;
static PyObject *const_str_plain_p;
static PyObject *const_tuple_str_plain_p_str_plain_b_tuple;
static PyObject *const_str_plain_value;
static PyObject *const_tuple_int_pos_2_int_pos_7_int_0_tuple;
static PyObject *const_str_plain___swig_setmethods__;
extern PyObject *const_str_plain_int;
static PyObject *const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple;
static PyObject *const_tuple_str_plain__pylibpd_tuple;
static PyObject *const_str_plain_pathname;
static PyObject *const_str_plain___libpd_getdollarzero;
static PyObject *const_int_neg_2;
static PyObject *const_str_plain___debug__;
static PyObject *const_int_neg_1;
static PyObject *const_str_plain_libpd_aftertouch;
static PyObject *const_str_plain_libpd_blocksize;
static PyObject *const_str_plain_libpd_write_array;
static PyObject *const_tuple_str_plain_inch_str_plain_outch_str_plain_srate_tuple;
static PyObject *const_str_plain_libpd_set_noteon_callback;
static PyObject *const_str_plain_sym;
static PyObject *const_str_plain_libpd_polyaftertouch;
static PyObject *const_tuple_str_plain_dest_str_plain_args_tuple;
static PyObject *const_tuple_str_dot_tuple;
static PyObject *const_str_plain__object;
static PyObject *const_str_plain_inbuf;
static PyObject *const_str_plain_libpd_clear_search_path;
static PyObject *const_str_plain_libpd_set_float_callback;
static PyObject *const_str_plain__swig_setattr;
extern PyObject *const_str_plain_pylibpd;
static PyObject *const_str_plain_find_module;
static PyObject *const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
static PyObject *const_tuple_str_plain_ch_str_plain_p_tuple;
static PyObject *const_str_plain_outb;
static PyObject *const_str_plain_libpd_arraysize;
static PyObject *const_str_plain_dz;
static PyObject *const_str_plain_libpd_midibyte;
static PyObject *const_tuple_int_pos_2_int_pos_6_int_0_tuple;
static PyObject *const_tuple_str_plain_sym_tuple;
static PyObject *const_str_plain_version_info;
extern PyObject *const_str_plain___file__;
extern PyObject *const_int_pos_6;
static PyObject *const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple;
static PyObject *const_tuple_str_plain_dest_str_plain_val_tuple;
static PyObject *const_str_plain_strthis;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_1;
static PyObject *const_str_plain_libpd_set_list_callback;
static PyObject *const_str_plain_str;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_digest_11dda6802c4e85aab42c2a57cc2ae2a9;
static PyObject *const_str_plain_libpd_set_symbol_callback;
static PyObject *const_str_plain_libpd_sysrealtime;
static PyObject *const_str_plain_arg;
static PyObject *const_str_plain_libpd_release;
static PyObject *const_str_digest_49aeafda3f6d3de6fe167dc090ca3880;
static PyObject *const_str_plain_dirname;
static PyObject *const_str_plain_dsp;
static PyObject *const_str_plain__swig_repr;
static PyObject *const_str_plain_array;
static PyObject *const_tuple_str_plain_flag_tuple;
static PyObject *const_str_plain_libpd_process_raw;
static PyObject *const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple;
static PyObject *const_str_plain_ptr;
static PyObject *const_str_plain___init__;
static PyObject *const_str_plain_libpd_init_audio;
static PyObject *const_tuple_str_plain_callback_tuple;
static PyObject *const_str_plain_libpd_pitchbend;
extern PyObject *const_str_plain_libpd_bang;
static PyObject *const_str_plain___libpd_closefile;
extern PyObject *const_str_plain_libpd_subscribe;
extern PyObject *const_str_dot;
static PyObject *const_str_plain_libpd_set_midibyte_callback;
static PyObject *const_str_plain_join;
static PyObject *const_str_plain___libpd_bind;
static PyObject *const_tuple_str_plain_inb_str_plain_outb_tuple;
static PyObject *const_str_plain_libpd_exists;
static PyObject *const_tuple_str_plain_ch_str_plain_b_tuple;
static PyObject *const_str_plain_values;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_libpd_float;
static PyObject *const_tuple_str_plain_arg1_tuple;
static PyObject *const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple;
static PyObject *const_str_plain___libpd_subscriptions;
static PyObject *const_str_plain_libpd_process_short;
static PyObject *const_tuple_str_plain_ch_str_plain_v_tuple;
static PyObject *const_str_digest_ae9f5c2d055786b8851c555eb34480de;
static PyObject *const_str_plain___libpd_start_message;
static PyObject *const_str_plain___libpd_finish_list;
static PyObject *const_str_plain_libpd_set_pitchbend_callback;
static PyObject *const_str_plain_flag;
extern PyObject *const_int_pos_7;
static PyObject *const_str_plain_fp;
static PyObject *const_str_plain_method;
static PyObject *const_str_plain_arg2;
static PyObject *const_str_plain_src;
static PyObject *const_str_plain_libpd_noteon;
extern PyObject *const_str_plain___setattr__;
static PyObject *const_str_plain_libpd_list;
static PyObject *const_str_plain_n;
static PyObject *const_str_plain_h;
static PyObject *const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple;
static PyObject *const_str_plain_offset;
static PyObject *const_tuple_str_plain_dest_tuple;
static PyObject *const_str_plain_dest;
static PyObject *const_str_plain_b;
static PyObject *const_str_plain_lstrip;
static PyObject *const_str_plain_libpd_process_double;
static PyObject *const_str_plain___libpd_add_symbol;
extern PyObject *const_str_plain_name;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_str_plain_libpd_set_polyaftertouch_callback;
static PyObject *const_str_plain__mod;
static PyObject *const_str_plain___libpd_add_float;
static PyObject *const_str_plain_srate;
static PyObject *const_str_plain_ch;
static PyObject *const_str_plain_object;
static PyObject *const_str_plain_static;
static PyObject *const_str_plain_class_type;
static PyObject *const_str_plain_pkg;
static PyObject *const_str_plain__swig_property;
static PyObject *const_str_digest_c23a75f49d270ce4a86073969dab3371;
static PyObject *const_str_plain_mname;
static PyObject *const_str_plain_libpd_compute_audio;
static PyObject *const_str_plain_clear;
static PyObject *const_str_plain__newclass;
static PyObject *const_str_plain_libpd_set_aftertouch_callback;
extern PyObject *const_str_plain_False;
static PyObject *const_str_plain_libpd_close_patch;
static PyObject *const_str_plain_libpd_process_float;
static PyObject *const_str_plain_libpd_add_to_search_path;
static PyObject *const_str_plain_libpd_read_array;
static PyObject *const_str_plain_patch;
static PyObject *const_str_plain___libpd_unbind;
static PyObject *const_str_plain_imp;
static PyObject *const_str_plain_Exception;
static PyObject *const_str_plain__swig_python_version_info;
static PyObject *const_tuple_int_pos_1_tuple;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain_load_module;
static PyObject *const_str_plain_v;
extern PyObject *const_int_0;
static PyObject *const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_strthis_tuple;
static PyObject *const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple;
static PyObject *const_str_plain_thisown;
static PyObject *const_str_plain_libpd_set_controlchange_callback;
static PyObject *const_str_plain_val;
static PyObject *const_str_plain___libpd_patches;
static PyObject *const_str_plain_description;
static PyObject *const_str_plain__swig_getattr;
extern PyObject *const_str_plain_callback;
static PyObject *const_str_plain__PdManager__ticks;
static PyObject *const_str_plain_this;
extern PyObject *const_str_empty;
static PyObject *const_str_plain_float;
static PyObject *const_str_plain_has_key;
static PyObject *const_str_plain_dir;
static PyObject *const_str_plain_importlib;
static PyObject *const_str_plain_pd;
static PyObject *const_tuple_str_plain_mname_str_plain_importlib_str_plain_pkg_tuple;
static PyObject *const_str_plain_import_module;
static PyObject *const_str_plain__PdManager__outbuf;
static PyObject *const_str_plain___swig_getmethods__;
static PyObject *const_tuple_str_plain_dirname_tuple;
static PyObject *const_str_plain_libpd_controlchange;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_str_digest_d8498194b4aa4245dad6dd2c71b3dbb9 = UNSTREAM_STRING( &constant_bin[ 1661 ], 2, 0 );
    const_str_plain_libpd_message = UNSTREAM_STRING( &constant_bin[ 1663 ], 13, 1 );
    const_str_plain_builtins = UNSTREAM_STRING( &constant_bin[ 1676 ], 8, 1 );
    const_str_plain_get = UNSTREAM_STRING( &constant_bin[ 1684 ], 3, 1 );
    const_tuple_str_plain_dir_tuple = PyTuple_New( 1 );
    const_str_plain_dir = UNSTREAM_STRING( &constant_bin[ 1687 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dir_tuple, 0, const_str_plain_dir ); Py_INCREF( const_str_plain_dir );
    const_tuple_str_plain_dest_str_plain_sym_str_plain_args_tuple = PyTuple_New( 3 );
    const_str_plain_dest = UNSTREAM_STRING( &constant_bin[ 1690 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_sym_str_plain_args_tuple, 0, const_str_plain_dest ); Py_INCREF( const_str_plain_dest );
    const_str_plain_sym = UNSTREAM_STRING( &constant_bin[ 1694 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_sym_str_plain_args_tuple, 1, const_str_plain_sym ); Py_INCREF( const_str_plain_sym );
    const_str_plain_args = UNSTREAM_STRING( &constant_bin[ 1697 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_sym_str_plain_args_tuple, 2, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    const_str_plain_ticks = UNSTREAM_STRING( &constant_bin[ 1701 ], 5, 1 );
    const_tuple_str_plain_args_str_plain_arg_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_arg_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    const_str_plain_arg = UNSTREAM_STRING( &constant_bin[ 174 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_arg_tuple, 1, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple = PyTuple_New( 7 );
    const_str_plain_fp = UNSTREAM_STRING( &constant_bin[ 1706 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 0, const_str_plain_fp ); Py_INCREF( const_str_plain_fp );
    const_str_plain_description = UNSTREAM_STRING( &constant_bin[ 1708 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 1, const_str_plain_description ); Py_INCREF( const_str_plain_description );
    const_str_plain__pylibpd = UNSTREAM_STRING( &constant_bin[ 1719 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 2, const_str_plain__pylibpd ); Py_INCREF( const_str_plain__pylibpd );
    const_str_plain_imp = UNSTREAM_STRING( &constant_bin[ 1727 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 3, const_str_plain_imp ); Py_INCREF( const_str_plain_imp );
    const_str_plain_pathname = UNSTREAM_STRING( &constant_bin[ 1730 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 4, const_str_plain_pathname ); Py_INCREF( const_str_plain_pathname );
    const_str_plain_dirname = UNSTREAM_STRING( &constant_bin[ 1738 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 5, const_str_plain_dirname ); Py_INCREF( const_str_plain_dirname );
    const_str_plain__mod = UNSTREAM_STRING( &constant_bin[ 1745 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 6, const_str_plain__mod ); Py_INCREF( const_str_plain__mod );
    const_str_plain_libpd_programchange = UNSTREAM_STRING( &constant_bin[ 1749 ], 19, 1 );
    const_str_plain__swig_setattr_nondynamic = UNSTREAM_STRING( &constant_bin[ 1768 ], 24, 1 );
    const_str_plain_property = UNSTREAM_STRING( &constant_bin[ 1792 ], 8, 1 );
    const_tuple_b13917ad0b5118481f8f4f005491270c_tuple = PyTuple_New( 4 );
    const_str_plain_self = UNSTREAM_STRING( &constant_bin[ 1800 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_b13917ad0b5118481f8f4f005491270c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_class_type = UNSTREAM_STRING( &constant_bin[ 1804 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_b13917ad0b5118481f8f4f005491270c_tuple, 1, const_str_plain_class_type ); Py_INCREF( const_str_plain_class_type );
    PyTuple_SET_ITEM( const_tuple_b13917ad0b5118481f8f4f005491270c_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_method = UNSTREAM_STRING( &constant_bin[ 1814 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_b13917ad0b5118481f8f4f005491270c_tuple, 3, const_str_plain_method ); Py_INCREF( const_str_plain_method );
    const_tuple_str_plain_dest_str_plain_sym_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_sym_tuple, 0, const_str_plain_dest ); Py_INCREF( const_str_plain_dest );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_sym_tuple, 1, const_str_plain_sym ); Py_INCREF( const_str_plain_sym );
    const_str_plain_PdManager = UNSTREAM_STRING( &constant_bin[ 1820 ], 9, 1 );
    const_str_plain_libpd_unsubscribe = UNSTREAM_STRING( &constant_bin[ 1829 ], 17, 1 );
    const_str_plain_inch = UNSTREAM_STRING( &constant_bin[ 1846 ], 4, 1 );
    const_str_plain_libpd_symbol = UNSTREAM_STRING( &constant_bin[ 1850 ], 12, 1 );
    const_str_digest_e399ba4554180f37de594a6743234f17 = UNSTREAM_STRING( &constant_bin[ 1862 ], 7, 0 );
    const_str_plain_arg1 = UNSTREAM_STRING( &constant_bin[ 1869 ], 4, 1 );
    const_str_plain_libpd_set_bang_callback = UNSTREAM_STRING( &constant_bin[ 1873 ], 23, 1 );
    const_str_plain_swig_import_helper = UNSTREAM_STRING( &constant_bin[ 1896 ], 18, 1 );
    const_str_plain_SwigPyObject = UNSTREAM_STRING( &constant_bin[ 1914 ], 12, 1 );
    const_str_digest_44a910c126961a21fb78c77a5e30433a = UNSTREAM_STRING( &constant_bin[ 1926 ], 12, 0 );
    const_str_plain_rpartition = UNSTREAM_STRING( &constant_bin[ 1938 ], 10, 1 );
    const_str_plain_libpd_set_programchange_callback = UNSTREAM_STRING( &constant_bin[ 1948 ], 32, 1 );
    const_tuple_str_plain_arg1_str_plain_arg2_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_tuple, 0, const_str_plain_arg1 ); Py_INCREF( const_str_plain_arg1 );
    const_str_plain_arg2 = UNSTREAM_STRING( &constant_bin[ 1980 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_tuple, 1, const_str_plain_arg2 ); Py_INCREF( const_str_plain_arg2 );
    const_tuple_str_plain_self_str_plain_inbuf_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_inbuf_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_inbuf = UNSTREAM_STRING( &constant_bin[ 1984 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_inbuf_tuple, 1, const_str_plain_inbuf ); Py_INCREF( const_str_plain_inbuf );
    const_str_plain___repr__ = UNSTREAM_STRING( &constant_bin[ 1989 ], 8, 1 );
    const_tuple_str_plain_dz_tuple = PyTuple_New( 1 );
    const_str_plain_dz = UNSTREAM_STRING( &constant_bin[ 1997 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dz_tuple, 0, const_str_plain_dz ); Py_INCREF( const_str_plain_dz );
    const_str_plain___libpd_finish_message = UNSTREAM_STRING( &constant_bin[ 1999 ], 22, 1 );
    const_str_plain___process_args = UNSTREAM_STRING( &constant_bin[ 2021 ], 14, 1 );
    const_str_plain___libpd_openfile = UNSTREAM_STRING( &constant_bin[ 2035 ], 16, 1 );
    const_str_plain_libpd_set_print_callback = UNSTREAM_STRING( &constant_bin[ 2051 ], 24, 1 );
    const_str_plain_own = UNSTREAM_STRING( &constant_bin[ 1370 ], 3, 1 );
    const_str_plain_libpd_set_message_callback = UNSTREAM_STRING( &constant_bin[ 2075 ], 26, 1 );
    const_tuple_str_plain_name_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_name_tuple, 0, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_outch = UNSTREAM_STRING( &constant_bin[ 2101 ], 5, 1 );
    const_str_plain___builtin__ = UNSTREAM_STRING( &constant_bin[ 2106 ], 11, 1 );
    const_str_plain_inb = UNSTREAM_STRING( &constant_bin[ 1984 ], 3, 1 );
    const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple, 0, const_str_plain_dest ); Py_INCREF( const_str_plain_dest );
    const_str_plain_offset = UNSTREAM_STRING( &constant_bin[ 2117 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple, 1, const_str_plain_offset ); Py_INCREF( const_str_plain_offset );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple, 2, const_str_plain_inb ); Py_INCREF( const_str_plain_inb );
    const_str_plain_n = UNSTREAM_CHAR( 110, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple, 3, const_str_plain_n ); Py_INCREF( const_str_plain_n );
    const_str_plain_libpd_sysex = UNSTREAM_STRING( &constant_bin[ 2123 ], 11, 1 );
    const_str_plain_close = UNSTREAM_STRING( &constant_bin[ 2134 ], 5, 1 );
    const_tuple_str_plain_version_info_tuple = PyTuple_New( 1 );
    const_str_plain_version_info = UNSTREAM_STRING( &constant_bin[ 2139 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_version_info_tuple, 0, const_str_plain_version_info ); Py_INCREF( const_str_plain_version_info );
    const_tuple_str_plain_p_tuple = PyTuple_New( 1 );
    const_str_plain_p = UNSTREAM_CHAR( 112, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_p_tuple, 0, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    const_str_plain_process = UNSTREAM_STRING( &constant_bin[ 2023 ], 7, 1 );
    const_str_digest_07348ad52202465dc552f2bfab430ac3 = UNSTREAM_STRING( &constant_bin[ 2151 ], 9, 0 );
    const_tuple_str_plain_p_str_plain_b_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_p_str_plain_b_tuple, 0, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    const_str_plain_b = UNSTREAM_CHAR( 98, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_p_str_plain_b_tuple, 1, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    const_str_plain_value = UNSTREAM_STRING( &constant_bin[ 2160 ], 5, 1 );
    const_tuple_int_pos_2_int_pos_7_int_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_int_pos_2_int_pos_7_int_0_tuple, 0, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    PyTuple_SET_ITEM( const_tuple_int_pos_2_int_pos_7_int_0_tuple, 1, const_int_pos_7 ); Py_INCREF( const_int_pos_7 );
    PyTuple_SET_ITEM( const_tuple_int_pos_2_int_pos_7_int_0_tuple, 2, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain___swig_setmethods__ = UNSTREAM_STRING( &constant_bin[ 2165 ], 19, 1 );
    const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple, 0, const_str_plain_ticks ); Py_INCREF( const_str_plain_ticks );
    PyTuple_SET_ITEM( const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple, 1, const_str_plain_inb ); Py_INCREF( const_str_plain_inb );
    const_str_plain_outb = UNSTREAM_STRING( &constant_bin[ 2184 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple, 2, const_str_plain_outb ); Py_INCREF( const_str_plain_outb );
    const_tuple_str_plain__pylibpd_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__pylibpd_tuple, 0, const_str_plain__pylibpd ); Py_INCREF( const_str_plain__pylibpd );
    const_str_plain___libpd_getdollarzero = UNSTREAM_STRING( &constant_bin[ 2188 ], 21, 1 );
    const_int_neg_2 = PyInt_FromLong( -2l );
    const_str_plain___debug__ = UNSTREAM_STRING( &constant_bin[ 2209 ], 9, 1 );
    const_int_neg_1 = PyInt_FromLong( -1l );
    const_str_plain_libpd_aftertouch = UNSTREAM_STRING( &constant_bin[ 2218 ], 16, 1 );
    const_str_plain_libpd_blocksize = UNSTREAM_STRING( &constant_bin[ 2234 ], 15, 1 );
    const_str_plain_libpd_write_array = UNSTREAM_STRING( &constant_bin[ 2249 ], 17, 1 );
    const_tuple_str_plain_inch_str_plain_outch_str_plain_srate_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_inch_str_plain_outch_str_plain_srate_tuple, 0, const_str_plain_inch ); Py_INCREF( const_str_plain_inch );
    PyTuple_SET_ITEM( const_tuple_str_plain_inch_str_plain_outch_str_plain_srate_tuple, 1, const_str_plain_outch ); Py_INCREF( const_str_plain_outch );
    const_str_plain_srate = UNSTREAM_STRING( &constant_bin[ 2266 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_inch_str_plain_outch_str_plain_srate_tuple, 2, const_str_plain_srate ); Py_INCREF( const_str_plain_srate );
    const_str_plain_libpd_set_noteon_callback = UNSTREAM_STRING( &constant_bin[ 2271 ], 25, 1 );
    const_str_plain_libpd_polyaftertouch = UNSTREAM_STRING( &constant_bin[ 2296 ], 20, 1 );
    const_tuple_str_plain_dest_str_plain_args_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_args_tuple, 0, const_str_plain_dest ); Py_INCREF( const_str_plain_dest );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_args_tuple, 1, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    const_tuple_str_dot_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_dot_tuple, 0, const_str_dot ); Py_INCREF( const_str_dot );
    const_str_plain__object = UNSTREAM_STRING( &constant_bin[ 2316 ], 7, 1 );
    const_str_plain_libpd_clear_search_path = UNSTREAM_STRING( &constant_bin[ 2323 ], 23, 1 );
    const_str_plain_libpd_set_float_callback = UNSTREAM_STRING( &constant_bin[ 2346 ], 24, 1 );
    const_str_plain__swig_setattr = UNSTREAM_STRING( &constant_bin[ 1768 ], 13, 1 );
    const_str_plain_find_module = UNSTREAM_STRING( &constant_bin[ 2370 ], 11, 1 );
    const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e = UNSTREAM_STRING( &constant_bin[ 2381 ], 33, 0 );
    const_tuple_str_plain_ch_str_plain_p_tuple = PyTuple_New( 2 );
    const_str_plain_ch = UNSTREAM_STRING( &constant_bin[ 172 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_p_tuple, 0, const_str_plain_ch ); Py_INCREF( const_str_plain_ch );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_p_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    const_str_plain_libpd_arraysize = UNSTREAM_STRING( &constant_bin[ 2414 ], 15, 1 );
    const_str_plain_libpd_midibyte = UNSTREAM_STRING( &constant_bin[ 2429 ], 14, 1 );
    const_tuple_int_pos_2_int_pos_6_int_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_int_pos_2_int_pos_6_int_0_tuple, 0, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    PyTuple_SET_ITEM( const_tuple_int_pos_2_int_pos_6_int_0_tuple, 1, const_int_pos_6 ); Py_INCREF( const_int_pos_6 );
    PyTuple_SET_ITEM( const_tuple_int_pos_2_int_pos_6_int_0_tuple, 2, const_int_0 ); Py_INCREF( const_int_0 );
    const_tuple_str_plain_sym_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_sym_tuple, 0, const_str_plain_sym ); Py_INCREF( const_str_plain_sym );
    const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple, 0, const_str_plain_outb ); Py_INCREF( const_str_plain_outb );
    const_str_plain_src = UNSTREAM_STRING( &constant_bin[ 2443 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple, 1, const_str_plain_src ); Py_INCREF( const_str_plain_src );
    PyTuple_SET_ITEM( const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple, 2, const_str_plain_offset ); Py_INCREF( const_str_plain_offset );
    PyTuple_SET_ITEM( const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple, 3, const_str_plain_n ); Py_INCREF( const_str_plain_n );
    const_tuple_str_plain_dest_str_plain_val_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_val_tuple, 0, const_str_plain_dest ); Py_INCREF( const_str_plain_dest );
    const_str_plain_val = UNSTREAM_STRING( &constant_bin[ 2160 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_str_plain_val_tuple, 1, const_str_plain_val ); Py_INCREF( const_str_plain_val );
    const_str_plain_strthis = UNSTREAM_STRING( &constant_bin[ 2446 ], 7, 1 );
    const_str_plain_libpd_set_list_callback = UNSTREAM_STRING( &constant_bin[ 2453 ], 23, 1 );
    const_str_plain_str = UNSTREAM_STRING( &constant_bin[ 315 ], 3, 1 );
    const_str_digest_11dda6802c4e85aab42c2a57cc2ae2a9 = UNSTREAM_STRING( &constant_bin[ 2476 ], 27, 0 );
    const_str_plain_libpd_set_symbol_callback = UNSTREAM_STRING( &constant_bin[ 2503 ], 25, 1 );
    const_str_plain_libpd_sysrealtime = UNSTREAM_STRING( &constant_bin[ 2528 ], 17, 1 );
    const_str_plain_libpd_release = UNSTREAM_STRING( &constant_bin[ 2545 ], 13, 1 );
    const_str_digest_49aeafda3f6d3de6fe167dc090ca3880 = UNSTREAM_STRING( &constant_bin[ 2558 ], 49, 0 );
    const_str_plain_dsp = UNSTREAM_STRING( &constant_bin[ 2607 ], 3, 1 );
    const_str_plain__swig_repr = UNSTREAM_STRING( &constant_bin[ 2610 ], 10, 1 );
    const_str_plain_array = UNSTREAM_STRING( &constant_bin[ 2261 ], 5, 1 );
    const_tuple_str_plain_flag_tuple = PyTuple_New( 1 );
    const_str_plain_flag = UNSTREAM_STRING( &constant_bin[ 2620 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_tuple, 0, const_str_plain_flag ); Py_INCREF( const_str_plain_flag );
    const_str_plain_libpd_process_raw = UNSTREAM_STRING( &constant_bin[ 2624 ], 17, 1 );
    const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple, 1, const_str_plain_inch ); Py_INCREF( const_str_plain_inch );
    PyTuple_SET_ITEM( const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple, 2, const_str_plain_outch ); Py_INCREF( const_str_plain_outch );
    PyTuple_SET_ITEM( const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple, 3, const_str_plain_srate ); Py_INCREF( const_str_plain_srate );
    PyTuple_SET_ITEM( const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple, 4, const_str_plain_ticks ); Py_INCREF( const_str_plain_ticks );
    const_str_plain_ptr = UNSTREAM_STRING( &constant_bin[ 2641 ], 3, 1 );
    const_str_plain___init__ = UNSTREAM_STRING( &constant_bin[ 85 ], 8, 1 );
    const_str_plain_libpd_init_audio = UNSTREAM_STRING( &constant_bin[ 2644 ], 16, 1 );
    const_tuple_str_plain_callback_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_callback_tuple, 0, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_libpd_pitchbend = UNSTREAM_STRING( &constant_bin[ 2660 ], 15, 1 );
    const_str_plain___libpd_closefile = UNSTREAM_STRING( &constant_bin[ 2675 ], 17, 1 );
    const_str_plain_libpd_set_midibyte_callback = UNSTREAM_STRING( &constant_bin[ 2692 ], 27, 1 );
    const_str_plain_join = UNSTREAM_STRING( &constant_bin[ 2719 ], 4, 1 );
    const_str_plain___libpd_bind = UNSTREAM_STRING( &constant_bin[ 2723 ], 12, 1 );
    const_tuple_str_plain_inb_str_plain_outb_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_inb_str_plain_outb_tuple, 0, const_str_plain_inb ); Py_INCREF( const_str_plain_inb );
    PyTuple_SET_ITEM( const_tuple_str_plain_inb_str_plain_outb_tuple, 1, const_str_plain_outb ); Py_INCREF( const_str_plain_outb );
    const_str_plain_libpd_exists = UNSTREAM_STRING( &constant_bin[ 2735 ], 12, 1 );
    const_tuple_str_plain_ch_str_plain_b_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_b_tuple, 0, const_str_plain_ch ); Py_INCREF( const_str_plain_ch );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_b_tuple, 1, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    const_str_plain_values = UNSTREAM_STRING( &constant_bin[ 2747 ], 6, 1 );
    const_str_plain_libpd_float = UNSTREAM_STRING( &constant_bin[ 2753 ], 11, 1 );
    const_tuple_str_plain_arg1_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_tuple, 0, const_str_plain_arg1 ); Py_INCREF( const_str_plain_arg1 );
    const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple, 1, const_str_plain_class_type ); Py_INCREF( const_str_plain_class_type );
    PyTuple_SET_ITEM( const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple, 3, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    const_str_plain___libpd_subscriptions = UNSTREAM_STRING( &constant_bin[ 2764 ], 21, 1 );
    const_str_plain_libpd_process_short = UNSTREAM_STRING( &constant_bin[ 2785 ], 19, 1 );
    const_tuple_str_plain_ch_str_plain_v_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_v_tuple, 0, const_str_plain_ch ); Py_INCREF( const_str_plain_ch );
    const_str_plain_v = UNSTREAM_CHAR( 118, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_v_tuple, 1, const_str_plain_v ); Py_INCREF( const_str_plain_v );
    const_str_digest_ae9f5c2d055786b8851c555eb34480de = UNSTREAM_STRING( &constant_bin[ 2804 ], 31, 0 );
    const_str_plain___libpd_start_message = UNSTREAM_STRING( &constant_bin[ 2835 ], 21, 1 );
    const_str_plain___libpd_finish_list = UNSTREAM_STRING( &constant_bin[ 2856 ], 19, 1 );
    const_str_plain_libpd_set_pitchbend_callback = UNSTREAM_STRING( &constant_bin[ 2875 ], 28, 1 );
    const_str_plain_libpd_noteon = UNSTREAM_STRING( &constant_bin[ 2903 ], 12, 1 );
    const_str_plain_libpd_list = UNSTREAM_STRING( &constant_bin[ 2915 ], 10, 1 );
    const_str_plain_h = UNSTREAM_CHAR( 104, 1 );
    const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple = PyTuple_New( 4 );
    const_str_plain_patch = UNSTREAM_STRING( &constant_bin[ 2491 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple, 0, const_str_plain_patch ); Py_INCREF( const_str_plain_patch );
    PyTuple_SET_ITEM( const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple, 1, const_str_plain_dir ); Py_INCREF( const_str_plain_dir );
    PyTuple_SET_ITEM( const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple, 2, const_str_plain_dz ); Py_INCREF( const_str_plain_dz );
    PyTuple_SET_ITEM( const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple, 3, const_str_plain_ptr ); Py_INCREF( const_str_plain_ptr );
    const_tuple_str_plain_dest_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dest_tuple, 0, const_str_plain_dest ); Py_INCREF( const_str_plain_dest );
    const_str_plain_lstrip = UNSTREAM_STRING( &constant_bin[ 2925 ], 6, 1 );
    const_str_plain_libpd_process_double = UNSTREAM_STRING( &constant_bin[ 2931 ], 20, 1 );
    const_str_plain___libpd_add_symbol = UNSTREAM_STRING( &constant_bin[ 2951 ], 18, 1 );
    const_str_plain_libpd_set_polyaftertouch_callback = UNSTREAM_STRING( &constant_bin[ 2969 ], 33, 1 );
    const_str_plain___libpd_add_float = UNSTREAM_STRING( &constant_bin[ 3002 ], 17, 1 );
    const_str_plain_object = UNSTREAM_STRING( &constant_bin[ 2317 ], 6, 1 );
    const_str_plain_static = UNSTREAM_STRING( &constant_bin[ 3019 ], 6, 1 );
    const_str_plain_pkg = UNSTREAM_STRING( &constant_bin[ 3025 ], 3, 1 );
    const_str_plain__swig_property = UNSTREAM_STRING( &constant_bin[ 3028 ], 14, 1 );
    const_str_digest_c23a75f49d270ce4a86073969dab3371 = UNSTREAM_STRING( &constant_bin[ 3042 ], 16, 0 );
    const_str_plain_mname = UNSTREAM_STRING( &constant_bin[ 3058 ], 5, 1 );
    const_str_plain_libpd_compute_audio = UNSTREAM_STRING( &constant_bin[ 3063 ], 19, 1 );
    const_str_plain_clear = UNSTREAM_STRING( &constant_bin[ 2329 ], 5, 1 );
    const_str_plain__newclass = UNSTREAM_STRING( &constant_bin[ 3082 ], 9, 1 );
    const_str_plain_libpd_set_aftertouch_callback = UNSTREAM_STRING( &constant_bin[ 3091 ], 29, 1 );
    const_str_plain_libpd_close_patch = UNSTREAM_STRING( &constant_bin[ 3120 ], 17, 1 );
    const_str_plain_libpd_process_float = UNSTREAM_STRING( &constant_bin[ 3137 ], 19, 1 );
    const_str_plain_libpd_add_to_search_path = UNSTREAM_STRING( &constant_bin[ 3156 ], 24, 1 );
    const_str_plain_libpd_read_array = UNSTREAM_STRING( &constant_bin[ 3180 ], 16, 1 );
    const_str_plain___libpd_unbind = UNSTREAM_STRING( &constant_bin[ 3196 ], 14, 1 );
    const_str_plain_Exception = UNSTREAM_STRING( &constant_bin[ 3210 ], 9, 1 );
    const_str_plain__swig_python_version_info = UNSTREAM_STRING( &constant_bin[ 3219 ], 25, 1 );
    const_tuple_int_pos_1_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_int_pos_1_tuple, 0, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    const_str_plain_load_module = UNSTREAM_STRING( &constant_bin[ 3244 ], 11, 1 );
    const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple, 0, const_str_plain_ch ); Py_INCREF( const_str_plain_ch );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple, 1, const_str_plain_n ); Py_INCREF( const_str_plain_n );
    PyTuple_SET_ITEM( const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple, 2, const_str_plain_v ); Py_INCREF( const_str_plain_v );
    const_tuple_str_plain_self_str_plain_strthis_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_strthis_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_strthis_tuple, 1, const_str_plain_strthis ); Py_INCREF( const_str_plain_strthis );
    const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 1, const_str_plain_class_type ); Py_INCREF( const_str_plain_class_type );
    PyTuple_SET_ITEM( const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 3, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 4, const_str_plain_static ); Py_INCREF( const_str_plain_static );
    PyTuple_SET_ITEM( const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 5, const_str_plain_method ); Py_INCREF( const_str_plain_method );
    const_str_plain_thisown = UNSTREAM_STRING( &constant_bin[ 3255 ], 7, 1 );
    const_str_plain_libpd_set_controlchange_callback = UNSTREAM_STRING( &constant_bin[ 3262 ], 32, 1 );
    const_str_plain___libpd_patches = UNSTREAM_STRING( &constant_bin[ 3294 ], 15, 1 );
    const_str_plain__swig_getattr = UNSTREAM_STRING( &constant_bin[ 3309 ], 13, 1 );
    const_str_plain__PdManager__ticks = UNSTREAM_STRING( &constant_bin[ 3322 ], 17, 1 );
    const_str_plain_this = UNSTREAM_STRING( &constant_bin[ 214 ], 4, 1 );
    const_str_plain_float = UNSTREAM_STRING( &constant_bin[ 2356 ], 5, 1 );
    const_str_plain_has_key = UNSTREAM_STRING( &constant_bin[ 3339 ], 7, 1 );
    const_str_plain_importlib = UNSTREAM_STRING( &constant_bin[ 3346 ], 9, 1 );
    const_str_plain_pd = UNSTREAM_STRING( &constant_bin[ 1331 ], 2, 1 );
    const_tuple_str_plain_mname_str_plain_importlib_str_plain_pkg_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_mname_str_plain_importlib_str_plain_pkg_tuple, 0, const_str_plain_mname ); Py_INCREF( const_str_plain_mname );
    PyTuple_SET_ITEM( const_tuple_str_plain_mname_str_plain_importlib_str_plain_pkg_tuple, 1, const_str_plain_importlib ); Py_INCREF( const_str_plain_importlib );
    PyTuple_SET_ITEM( const_tuple_str_plain_mname_str_plain_importlib_str_plain_pkg_tuple, 2, const_str_plain_pkg ); Py_INCREF( const_str_plain_pkg );
    const_str_plain_import_module = UNSTREAM_STRING( &constant_bin[ 3355 ], 13, 1 );
    const_str_plain__PdManager__outbuf = UNSTREAM_STRING( &constant_bin[ 3368 ], 18, 1 );
    const_str_plain___swig_getmethods__ = UNSTREAM_STRING( &constant_bin[ 3386 ], 19, 1 );
    const_tuple_str_plain_dirname_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dirname_tuple, 0, const_str_plain_dirname ); Py_INCREF( const_str_plain_dirname );
    const_str_plain_libpd_controlchange = UNSTREAM_STRING( &constant_bin[ 3405 ], 19, 1 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_pylibpd( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_c874ce24acba0c1b5e4d06071c656789;
static PyCodeObject *codeobj_6ffef1c4183406a598a2b739920d352c;
static PyCodeObject *codeobj_f8a670eef22f494443ea2b9e7952c907;
static PyCodeObject *codeobj_9409a7b93d94702a4a69920ae04eb161;
static PyCodeObject *codeobj_aca50b06b384550b93d83ce16d52d8bf;
static PyCodeObject *codeobj_081627b32714c4dc4f79f1da7855cefe;
static PyCodeObject *codeobj_172af12e7cacf671fefe4dc3cb40b952;
static PyCodeObject *codeobj_08db12479674b55bb4e97286ce56e485;
static PyCodeObject *codeobj_7d03f83e6dcc89c3664b73e19d33999f;
static PyCodeObject *codeobj_ffe82fca45db6bdd4a31de8fd0802215;
static PyCodeObject *codeobj_97a2f5f9b43c1ac5b38cdffb015ad2e3;
static PyCodeObject *codeobj_d29ead87806ceb2eb05c06e32cd27a0d;
static PyCodeObject *codeobj_38c0d26bc756e19052564548acf50807;
static PyCodeObject *codeobj_ba9b8ae61fe4bb523340e957b1f4e083;
static PyCodeObject *codeobj_9d7f64f4db8767f12bf73f9bbb96e593;
static PyCodeObject *codeobj_31d62ac91c511fe21d095de46eb92ef7;
static PyCodeObject *codeobj_0c597563305462e9aa2ecc13cad43ab1;
static PyCodeObject *codeobj_0aefc78e9fc9d2a532bc1b9369744774;
static PyCodeObject *codeobj_0b068d00f991b4aa4c21b69db841c716;
static PyCodeObject *codeobj_071a47a91f9aed57f315c24786e5f01c;
static PyCodeObject *codeobj_2f2ef16995e2a75890649eda2fadfb87;
static PyCodeObject *codeobj_acf27e75a7097025445ee5215c567823;
static PyCodeObject *codeobj_343b5115a46b045f2a2143c29663c2cf;
static PyCodeObject *codeobj_1cacc913ed2a0459d4ecf08b45761e89;
static PyCodeObject *codeobj_6c96b23369e54e55433f0730b526faa9;
static PyCodeObject *codeobj_33b8c183561d8ad30ad8d6cc9e4f63ff;
static PyCodeObject *codeobj_d855202678d0be3f91372ec10aaf0bba;
static PyCodeObject *codeobj_e8f21a19af2747cccbab902149f03067;
static PyCodeObject *codeobj_3504f5a87d2a4feec5f4942b8d92c36d;
static PyCodeObject *codeobj_89383b11fa2394246d9479e8a9ffa0ce;
static PyCodeObject *codeobj_d9975fdcb0550d907412bc2e53163472;
static PyCodeObject *codeobj_c416fef52457d1894040227253d35001;
static PyCodeObject *codeobj_6a6079783c9362b20448bac27358928a;
static PyCodeObject *codeobj_134c2eef919a2e020ca576e89a1ef1b0;
static PyCodeObject *codeobj_9b41b3f0701460461aebf73f01228470;
static PyCodeObject *codeobj_76349622e9ca983d63f713959371dedd;
static PyCodeObject *codeobj_0cb4bd587a57e70362d1db49a3a5990f;
static PyCodeObject *codeobj_ac4c9fe1769bc11600950c3944287e34;
static PyCodeObject *codeobj_6a0ddd42e1b7a5a4152a4240159ad237;
static PyCodeObject *codeobj_e3b16727cdeb05738c4c9320beae9d9b;
static PyCodeObject *codeobj_02a37784f2b45c3c669122f5502c92b7;
static PyCodeObject *codeobj_6c62e24c2138b71b7592c5ef03e03f2e;
static PyCodeObject *codeobj_8e38145e52b56d5eb777ffae239d8856;
static PyCodeObject *codeobj_0e508c26b2577e99373cc510f79d1d17;
static PyCodeObject *codeobj_9f609cf12fb6702b215ca4e190df0150;
static PyCodeObject *codeobj_93d9ddc9137f0c15be485242480929e6;
static PyCodeObject *codeobj_8386f14fa7ef7a1472148a612707d53d;
static PyCodeObject *codeobj_49832756a35e30a84f59c4adf04e130d;
static PyCodeObject *codeobj_d504bddcee8e4411a09cb993d761ed73;
static PyCodeObject *codeobj_353278295782574f178182e484b36135;
static PyCodeObject *codeobj_91e54d526b6875d6ecdee23c34416080;
static PyCodeObject *codeobj_2aa96112640cdd6d7ba59bfefe4d05bb;
static PyCodeObject *codeobj_a940df66d49765e4a3a3cce2004dbdf3;
static PyCodeObject *codeobj_cc17d197781e6408060b20f3d83b6a4d;
static PyCodeObject *codeobj_e98ce42509d553edec565b589a3402b8;
static PyCodeObject *codeobj_939b16de371ad68ae9b6bfb148332ccf;
static PyCodeObject *codeobj_dfc3cb6cc00162b1590553f83958ba26;
static PyCodeObject *codeobj_cf2a7fe516656bccd925f44e5df336e1;
static PyCodeObject *codeobj_b686d52c1e30b795289b80675fc8585e;
static PyCodeObject *codeobj_bfe583942d63a0207ea73d35a4df9663;
static PyCodeObject *codeobj_4b73e8b34ff0b182963b09d6f49d1972;
static PyCodeObject *codeobj_7488e77d04da376327f8b18b5284652a;
static PyCodeObject *codeobj_160fd94ddde280b5cb4f44fbfad772ac;
static PyCodeObject *codeobj_ab62304def253682cced856ce07894d3;
static PyCodeObject *codeobj_e45d2fa245588a22f6c5adeaa3e1bf1c;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_49aeafda3f6d3de6fe167dc090ca3880;
    codeobj_c874ce24acba0c1b5e4d06071c656789 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_c23a75f49d270ce4a86073969dab3371, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_6ffef1c4183406a598a2b739920d352c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 343, const_tuple_f0ba33cf77d3bfeb079e0cc40cdcce0a_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f8a670eef22f494443ea2b9e7952c907 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_add_float, 159, const_tuple_str_plain_arg1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9409a7b93d94702a4a69920ae04eb161 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_add_symbol, 163, const_tuple_str_plain_arg1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aca50b06b384550b93d83ce16d52d8bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_bind, 179, const_tuple_str_plain_sym_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_081627b32714c4dc4f79f1da7855cefe = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_closefile, 191, const_tuple_str_plain_arg1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_172af12e7cacf671fefe4dc3cb40b952 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_finish_list, 167, const_tuple_str_plain_arg1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_08db12479674b55bb4e97286ce56e485 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_finish_message, 171, const_tuple_str_plain_arg1_str_plain_arg2_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7d03f83e6dcc89c3664b73e19d33999f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_getdollarzero, 195, const_tuple_str_plain_arg1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ffe82fca45db6bdd4a31de8fd0802215 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_openfile, 187, const_tuple_str_plain_arg1_str_plain_arg2_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_97a2f5f9b43c1ac5b38cdffb015ad2e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_start_message, 155, const_tuple_str_plain_arg1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d29ead87806ceb2eb05c06e32cd27a0d = MAKE_CODEOBJ( module_filename_obj, const_str_plain___libpd_unbind, 183, const_tuple_str_plain_p_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_38c0d26bc756e19052564548acf50807 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___process_args, 289, const_tuple_str_plain_args_str_plain_arg_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ba9b8ae61fe4bb523340e957b1f4e083 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__swig_getattr, 74, const_tuple_b13917ad0b5118481f8f4f005491270c_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9d7f64f4db8767f12bf73f9bbb96e593 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__swig_repr, 83, const_tuple_str_plain_self_str_plain_strthis_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_31d62ac91c511fe21d095de46eb92ef7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__swig_setattr, 70, const_tuple_9fd96ee494ccf8b84dea7c595cfc2e30_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0c597563305462e9aa2ecc13cad43ab1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__swig_setattr_nondynamic, 51, const_tuple_1a274e47b10c5ed01726bd1a57ea75a4_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0aefc78e9fc9d2a532bc1b9369744774 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_add_to_search_path, 103, const_tuple_str_plain_dir_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0b068d00f991b4aa4c21b69db841c716 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_aftertouch, 215, const_tuple_str_plain_ch_str_plain_v_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_071a47a91f9aed57f315c24786e5f01c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_arraysize, 131, const_tuple_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f2ef16995e2a75890649eda2fadfb87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_bang, 143, const_tuple_str_plain_dest_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_acf27e75a7097025445ee5215c567823 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_blocksize, 107, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_343b5115a46b045f2a2143c29663c2cf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_clear_search_path, 99, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1cacc913ed2a0459d4ecf08b45761e89 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_close_patch, 317, const_tuple_str_plain_dz_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6c96b23369e54e55433f0730b526faa9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_compute_audio, 331, const_tuple_str_plain_flag_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_33b8c183561d8ad30ad8d6cc9e4f63ff = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_controlchange, 203, const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d855202678d0be3f91372ec10aaf0bba = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_exists, 175, const_tuple_str_plain_sym_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e8f21a19af2747cccbab902149f03067 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_float, 147, const_tuple_str_plain_dest_str_plain_val_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3504f5a87d2a4feec5f4942b8d92c36d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_init_audio, 111, const_tuple_str_plain_inch_str_plain_outch_str_plain_srate_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_89383b11fa2394246d9479e8a9ffa0ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_list, 301, const_tuple_str_plain_dest_str_plain_args_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_d9975fdcb0550d907412bc2e53163472 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_message, 304, const_tuple_str_plain_dest_str_plain_sym_str_plain_args_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_c416fef52457d1894040227253d35001 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_midibyte, 223, const_tuple_str_plain_p_str_plain_b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a6079783c9362b20448bac27358928a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_noteon, 199, const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_134c2eef919a2e020ca576e89a1ef1b0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_open_patch, 309, const_tuple_str_plain_patch_str_plain_dir_str_plain_dz_str_plain_ptr_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9b41b3f0701460461aebf73f01228470 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_pitchbend, 211, const_tuple_str_plain_ch_str_plain_b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_76349622e9ca983d63f713959371dedd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_polyaftertouch, 219, const_tuple_str_plain_ch_str_plain_n_str_plain_v_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0cb4bd587a57e70362d1db49a3a5990f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_process_double, 127, const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ac4c9fe1769bc11600950c3944287e34 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_process_float, 119, const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a0ddd42e1b7a5a4152a4240159ad237 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_process_raw, 115, const_tuple_str_plain_inb_str_plain_outb_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e3b16727cdeb05738c4c9320beae9d9b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_process_short, 123, const_tuple_str_plain_ticks_str_plain_inb_str_plain_outb_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_02a37784f2b45c3c669122f5502c92b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_programchange, 207, const_tuple_str_plain_ch_str_plain_p_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6c62e24c2138b71b7592c5ef03e03f2e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_read_array, 135, const_tuple_str_plain_outb_str_plain_src_str_plain_offset_str_plain_n_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8e38145e52b56d5eb777ffae239d8856 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_release, 334, const_tuple_str_plain_p_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0e508c26b2577e99373cc510f79d1d17 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_aftertouch_callback, 275, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9f609cf12fb6702b215ca4e190df0150 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_bang_callback, 239, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_93d9ddc9137f0c15be485242480929e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_controlchange_callback, 263, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8386f14fa7ef7a1472148a612707d53d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_float_callback, 243, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_49832756a35e30a84f59c4adf04e130d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_list_callback, 251, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d504bddcee8e4411a09cb993d761ed73 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_message_callback, 255, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_353278295782574f178182e484b36135 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_midibyte_callback, 283, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_91e54d526b6875d6ecdee23c34416080 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_noteon_callback, 259, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2aa96112640cdd6d7ba59bfefe4d05bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_pitchbend_callback, 271, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a940df66d49765e4a3a3cce2004dbdf3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_polyaftertouch_callback, 279, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cc17d197781e6408060b20f3d83b6a4d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_print_callback, 235, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e98ce42509d553edec565b589a3402b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_programchange_callback, 267, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_939b16de371ad68ae9b6bfb148332ccf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_set_symbol_callback, 247, const_tuple_str_plain_callback_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dfc3cb6cc00162b1590553f83958ba26 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_subscribe, 323, const_tuple_str_plain_sym_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cf2a7fe516656bccd925f44e5df336e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_symbol, 151, const_tuple_str_plain_dest_str_plain_sym_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b686d52c1e30b795289b80675fc8585e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_sysex, 227, const_tuple_str_plain_p_str_plain_b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bfe583942d63a0207ea73d35a4df9663 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_sysrealtime, 231, const_tuple_str_plain_p_str_plain_b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4b73e8b34ff0b182963b09d6f49d1972 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_unsubscribe, 327, const_tuple_str_plain_sym_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7488e77d04da376327f8b18b5284652a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_libpd_write_array, 139, const_tuple_str_plain_dest_str_plain_offset_str_plain_inb_str_plain_n_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_160fd94ddde280b5cb4f44fbfad772ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_process, 348, const_tuple_str_plain_self_str_plain_inbuf_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ab62304def253682cced856ce07894d3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_swig_import_helper, 9, const_tuple_str_plain_mname_str_plain_importlib_str_plain_pkg_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e45d2fa245588a22f6c5adeaa3e1bf1c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_swig_import_helper, 20, const_tuple_712fe4eed4e4ec658b04191bbdb4a776_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
static PyObject *MAKE_FUNCTION_pylibpd$$$function_10_libpd_init_audio(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_11_libpd_process_raw(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_12_libpd_process_float(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_13_libpd_process_short(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_14_libpd_process_double(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_15_libpd_arraysize(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_16_libpd_read_array(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_17_libpd_write_array(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_18_libpd_bang(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_19_libpd_float(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_1_swig_import_helper(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_20_libpd_symbol(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_21___libpd_start_message(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_22___libpd_add_float(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_23___libpd_add_symbol(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_24___libpd_finish_list(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_25___libpd_finish_message(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_26_libpd_exists(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_27___libpd_bind(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_28___libpd_unbind(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_29___libpd_openfile(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_2_swig_import_helper(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_30___libpd_closefile(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_31___libpd_getdollarzero(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_32_libpd_noteon(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_33_libpd_controlchange(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_34_libpd_programchange(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_35_libpd_pitchbend(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_36_libpd_aftertouch(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_37_libpd_polyaftertouch(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_38_libpd_midibyte(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_39_libpd_sysex(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_3__swig_setattr_nondynamic( PyObject *defaults );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_40_libpd_sysrealtime(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_41_libpd_set_print_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_42_libpd_set_bang_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_43_libpd_set_float_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_44_libpd_set_symbol_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_45_libpd_set_list_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_46_libpd_set_message_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_47_libpd_set_noteon_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_48_libpd_set_controlchange_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_49_libpd_set_programchange_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_4__swig_setattr(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_50_libpd_set_pitchbend_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_51_libpd_set_aftertouch_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_52_libpd_set_polyaftertouch_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_53_libpd_set_midibyte_callback(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_54___process_args(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_55_libpd_list(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_56_libpd_message(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_57_libpd_open_patch( PyObject *defaults );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_58_libpd_close_patch(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_59_libpd_subscribe(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_5__swig_getattr(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_60_libpd_unsubscribe(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_61_libpd_compute_audio(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_62_libpd_release(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_63___init__(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_64_process(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_6__swig_repr(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_7_libpd_clear_search_path(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_8_libpd_add_to_search_path(  );


static PyObject *MAKE_FUNCTION_pylibpd$$$function_9_libpd_blocksize(  );


// The module function definitions.
static PyObject *impl_pylibpd$$$function_1_swig_import_helper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_mname = NULL;
    PyObject *var_importlib = NULL;
    PyObject *var_pkg = NULL;
    struct Nuitka_FrameObject *frame_ab62304def253682cced856ce07894d3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ab62304def253682cced856ce07894d3 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab62304def253682cced856ce07894d3, codeobj_ab62304def253682cced856ce07894d3, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ab62304def253682cced856ce07894d3 = cache_frame_ab62304def253682cced856ce07894d3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab62304def253682cced856ce07894d3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab62304def253682cced856ce07894d3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_importlib;
        tmp_globals_name_1 = (PyObject *)moduledict_pylibpd;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = 10;
        tmp_assign_source_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 10;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_importlib == NULL );
        var_importlib = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_subscript_name_1;
        tmp_called_instance_1 = const_str_plain_pylibpd;
        frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = 11;
        tmp_subscribed_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_rpartition, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_int_0;
        tmp_assign_source_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkg == NULL );
        var_pkg = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_tuple_element_1;
        tmp_called_instance_3 = const_str_dot;
        CHECK_OBJECT( var_pkg );
        tmp_tuple_element_1 = var_pkg;
        tmp_args_element_name_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_element_name_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_str_plain__pylibpd;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_element_name_1, 1, tmp_tuple_element_1 );
        frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = 12;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_instance_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_join, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 12;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = 12;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_lstrip, &PyTuple_GET_ITEM( const_tuple_str_dot_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 12;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_mname == NULL );
        var_mname = tmp_assign_source_3;
    }
    // Tried code:
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_importlib );
        tmp_called_instance_4 = var_importlib;
        CHECK_OBJECT( var_mname );
        tmp_args_element_name_2 = var_mname;
        frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = 14;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_import_module, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_1_swig_import_helper );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_ab62304def253682cced856ce07894d3 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_ab62304def253682cced856ce07894d3, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_ab62304def253682cced856ce07894d3, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ImportError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_5;
            CHECK_OBJECT( var_importlib );
            tmp_called_instance_5 = var_importlib;
            frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = 16;
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_plain__pylibpd_tuple, 0 ) );

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 16;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 13;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_ab62304def253682cced856ce07894d3->m_frame) frame_ab62304def253682cced856ce07894d3->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_ab62304def253682cced856ce07894d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_ab62304def253682cced856ce07894d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_ab62304def253682cced856ce07894d3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab62304def253682cced856ce07894d3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab62304def253682cced856ce07894d3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab62304def253682cced856ce07894d3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab62304def253682cced856ce07894d3,
        type_description_1,
        var_mname,
        var_importlib,
        var_pkg
    );


    // Release cached frame.
    if ( frame_ab62304def253682cced856ce07894d3 == cache_frame_ab62304def253682cced856ce07894d3 )
    {
        Py_DECREF( frame_ab62304def253682cced856ce07894d3 );
    }
    cache_frame_ab62304def253682cced856ce07894d3 = NULL;

    assertFrameObject( frame_ab62304def253682cced856ce07894d3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_1_swig_import_helper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_mname );
    Py_DECREF( var_mname );
    var_mname = NULL;

    CHECK_OBJECT( (PyObject *)var_importlib );
    Py_DECREF( var_importlib );
    var_importlib = NULL;

    CHECK_OBJECT( (PyObject *)var_pkg );
    Py_DECREF( var_pkg );
    var_pkg = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_mname );
    var_mname = NULL;

    Py_XDECREF( var_importlib );
    var_importlib = NULL;

    Py_XDECREF( var_pkg );
    var_pkg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_1_swig_import_helper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_2_swig_import_helper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_fp = NULL;
    PyObject *var_description = NULL;
    PyObject *var__pylibpd = NULL;
    PyObject *var_imp = NULL;
    PyObject *var_pathname = NULL;
    PyObject *var_dirname = NULL;
    PyObject *var__mod = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_e45d2fa245588a22f6c5adeaa3e1bf1c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    static struct Nuitka_FrameObject *cache_frame_e45d2fa245588a22f6c5adeaa3e1bf1c = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e45d2fa245588a22f6c5adeaa3e1bf1c, codeobj_e45d2fa245588a22f6c5adeaa3e1bf1c, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e45d2fa245588a22f6c5adeaa3e1bf1c = cache_frame_e45d2fa245588a22f6c5adeaa3e1bf1c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e45d2fa245588a22f6c5adeaa3e1bf1c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_e399ba4554180f37de594a6743234f17;
        tmp_globals_name_1 = (PyObject *)moduledict_pylibpd;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_dirname_tuple;
        frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 21;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 21;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_dirname );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 21;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_dirname == NULL );
        var_dirname = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        tmp_name_name_2 = const_str_plain_imp;
        tmp_globals_name_2 = (PyObject *)moduledict_pylibpd;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 22;
        tmp_assign_source_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
        assert( !(tmp_assign_source_2 == NULL) );
        assert( var_imp == NULL );
        var_imp = tmp_assign_source_2;
    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_imp );
        tmp_source_name_1 = var_imp;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_find_module );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 25;
            type_description_1 = "ooooooo";
            goto try_except_handler_3;
        }
        tmp_args_element_name_1 = const_str_plain__pylibpd;
        CHECK_OBJECT( var_dirname );
        tmp_called_name_2 = var_dirname;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___file__ );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___file__ );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__file__" );
            exception_tb = NULL;

            exception_lineno = 25;
            type_description_1 = "ooooooo";
            goto try_except_handler_3;
        }

        tmp_args_element_name_3 = tmp_mvar_value_1;
        frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 25;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 25;
            type_description_1 = "ooooooo";
            goto try_except_handler_3;
        }
        tmp_args_element_name_2 = PyList_New( 1 );
        PyList_SET_ITEM( tmp_args_element_name_2, 0, tmp_list_element_1 );
        frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 25;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 25;
            type_description_1 = "ooooooo";
            goto try_except_handler_3;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 25;
            type_description_1 = "ooooooo";
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__source_iter == NULL );
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_3;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooo";
            exception_lineno = 25;
            goto try_except_handler_4;
        }
        assert( tmp_tuple_unpack_1__element_1 == NULL );
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooo";
            exception_lineno = 25;
            goto try_except_handler_4;
        }
        assert( tmp_tuple_unpack_1__element_2 == NULL );
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_unpack_3;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_3 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_3, 2 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ooooooo";
            exception_lineno = 25;
            goto try_except_handler_4;
        }
        assert( tmp_tuple_unpack_1__element_3 == NULL );
        tmp_tuple_unpack_1__element_3 = tmp_assign_source_6;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "ooooooo";
                    exception_lineno = 25;
                    goto try_except_handler_4;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "ooooooo";
            exception_lineno = 25;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_e45d2fa245588a22f6c5adeaa3e1bf1c, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_e45d2fa245588a22f6c5adeaa3e1bf1c, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ImportError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 26;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_name_name_3;
            PyObject *tmp_globals_name_3;
            PyObject *tmp_locals_name_3;
            PyObject *tmp_fromlist_name_3;
            tmp_name_name_3 = const_str_plain__pylibpd;
            tmp_globals_name_3 = (PyObject *)moduledict_pylibpd;
            tmp_locals_name_3 = Py_None;
            tmp_fromlist_name_3 = Py_None;
            frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 27;
            tmp_assign_source_7 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
            if ( tmp_assign_source_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 27;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert( var__pylibpd == NULL );
            var__pylibpd = tmp_assign_source_7;
        }
        CHECK_OBJECT( var__pylibpd );
        tmp_return_value = var__pylibpd;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 24;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame) frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_8;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;
        assert( var_fp == NULL );
        Py_INCREF( tmp_assign_source_8 );
        var_fp = tmp_assign_source_8;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;
        assert( var_pathname == NULL );
        Py_INCREF( tmp_assign_source_9 );
        var_pathname = tmp_assign_source_9;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_3 );
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_3;
        assert( var_description == NULL );
        Py_INCREF( tmp_assign_source_10 );
        var_description = tmp_assign_source_10;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT( var_imp );
        tmp_called_instance_1 = var_imp;
        tmp_args_element_name_4 = const_str_plain__pylibpd;
        CHECK_OBJECT( var_fp );
        tmp_args_element_name_5 = var_fp;
        CHECK_OBJECT( var_pathname );
        tmp_args_element_name_6 = var_pathname;
        CHECK_OBJECT( var_description );
        tmp_args_element_name_7 = var_description;
        frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 30;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_11 = CALL_METHOD_WITH_ARGS4( tmp_called_instance_1, const_str_plain_load_module, call_args );
        }

        if ( tmp_assign_source_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 30;
            type_description_1 = "ooooooo";
            goto try_except_handler_5;
        }
        assert( var__mod == NULL );
        var__mod = tmp_assign_source_11;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_fp );
        tmp_compexpr_left_2 = var_fp;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( var_fp );
            tmp_called_instance_2 = var_fp;
            frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 33;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_close );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                Py_DECREF( exception_keeper_type_4 );
                Py_XDECREF( exception_keeper_value_4 );
                Py_XDECREF( exception_keeper_tb_4 );

                exception_lineno = 33;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_fp );
        tmp_compexpr_left_3 = var_fp;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( var_fp );
            tmp_called_instance_3 = var_fp;
            frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame.f_lineno = 33;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_close );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 33;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_3:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e45d2fa245588a22f6c5adeaa3e1bf1c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e45d2fa245588a22f6c5adeaa3e1bf1c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e45d2fa245588a22f6c5adeaa3e1bf1c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e45d2fa245588a22f6c5adeaa3e1bf1c,
        type_description_1,
        var_fp,
        var_description,
        var__pylibpd,
        var_imp,
        var_pathname,
        var_dirname,
        var__mod
    );


    // Release cached frame.
    if ( frame_e45d2fa245588a22f6c5adeaa3e1bf1c == cache_frame_e45d2fa245588a22f6c5adeaa3e1bf1c )
    {
        Py_DECREF( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );
    }
    cache_frame_e45d2fa245588a22f6c5adeaa3e1bf1c = NULL;

    assertFrameObject( frame_e45d2fa245588a22f6c5adeaa3e1bf1c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var__mod );
    tmp_return_value = var__mod;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_2_swig_import_helper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_fp );
    var_fp = NULL;

    Py_XDECREF( var_description );
    var_description = NULL;

    Py_XDECREF( var__pylibpd );
    var__pylibpd = NULL;

    CHECK_OBJECT( (PyObject *)var_imp );
    Py_DECREF( var_imp );
    var_imp = NULL;

    Py_XDECREF( var_pathname );
    var_pathname = NULL;

    CHECK_OBJECT( (PyObject *)var_dirname );
    Py_DECREF( var_dirname );
    var_dirname = NULL;

    Py_XDECREF( var__mod );
    var__mod = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_fp );
    var_fp = NULL;

    Py_XDECREF( var_description );
    var_description = NULL;

    Py_XDECREF( var_imp );
    var_imp = NULL;

    Py_XDECREF( var_pathname );
    var_pathname = NULL;

    Py_XDECREF( var_dirname );
    var_dirname = NULL;

    Py_XDECREF( var__mod );
    var__mod = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_2_swig_import_helper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_3__swig_setattr_nondynamic( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_class_type = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *par_value = python_pars[ 3 ];
    PyObject *par_static = python_pars[ 4 ];
    PyObject *var_method = NULL;
    struct Nuitka_FrameObject *frame_0c597563305462e9aa2ecc13cad43ab1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0c597563305462e9aa2ecc13cad43ab1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c597563305462e9aa2ecc13cad43ab1, codeobj_0c597563305462e9aa2ecc13cad43ab1, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0c597563305462e9aa2ecc13cad43ab1 = cache_frame_0c597563305462e9aa2ecc13cad43ab1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c597563305462e9aa2ecc13cad43ab1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c597563305462e9aa2ecc13cad43ab1 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_1 = par_name;
        tmp_compexpr_right_1 = const_str_plain_thisown;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 52;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_this );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 53;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_value );
            tmp_args_element_name_1 = par_value;
            frame_0c597563305462e9aa2ecc13cad43ab1->m_frame.f_lineno = 53;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_own, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 53;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_2 = par_name;
        tmp_compexpr_right_2 = const_str_plain_this;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 54;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT( par_value );
            tmp_type_arg_1 = par_value;
            tmp_source_name_2 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_source_name_2 == NULL) );
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_3 = const_str_plain_SwigPyObject;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 55;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_ass_subvalue_1;
                PyObject *tmp_ass_subscribed_1;
                PyObject *tmp_source_name_3;
                PyObject *tmp_ass_subscript_1;
                CHECK_OBJECT( par_value );
                tmp_ass_subvalue_1 = par_value;
                CHECK_OBJECT( par_self );
                tmp_source_name_3 = par_self;
                tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE_DICT_SLOT( tmp_source_name_3 );
                if ( tmp_ass_subscribed_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 56;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_name );
                tmp_ass_subscript_1 = par_name;
                tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
                Py_DECREF( tmp_ass_subscribed_1 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 56;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
            }
            tmp_return_value = Py_None;
            Py_INCREF( tmp_return_value );
            goto frame_return_exit_1;
            branch_no_3:;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_class_type );
        tmp_source_name_4 = par_class_type;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___swig_setmethods__ );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 58;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_args_element_name_2 = par_name;
        tmp_args_element_name_3 = Py_None;
        frame_0c597563305462e9aa2ecc13cad43ab1->m_frame.f_lineno = 58;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_get, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 58;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_method == NULL );
        var_method = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_method );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_method );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 59;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( var_method );
            tmp_called_name_1 = var_method;
            CHECK_OBJECT( par_self );
            tmp_args_element_name_4 = par_self;
            CHECK_OBJECT( par_value );
            tmp_args_element_name_5 = par_value;
            frame_0c597563305462e9aa2ecc13cad43ab1->m_frame.f_lineno = 60;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 60;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_static );
        tmp_operand_name_1 = par_static;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 61;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_mvar_value_1;
            int tmp_truth_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__newclass );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__newclass );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_newclass" );
                exception_tb = NULL;

                exception_lineno = 62;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_truth_name_2 = CHECK_IF_TRUE( tmp_mvar_value_1 );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 62;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_6 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_args_element_name_8;
                tmp_called_instance_3 = (PyObject *)&PyBaseObject_Type;
                CHECK_OBJECT( par_self );
                tmp_args_element_name_6 = par_self;
                CHECK_OBJECT( par_name );
                tmp_args_element_name_7 = par_name;
                CHECK_OBJECT( par_value );
                tmp_args_element_name_8 = par_value;
                frame_0c597563305462e9aa2ecc13cad43ab1->m_frame.f_lineno = 63;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_3, const_str_plain___setattr__, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 63;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            goto branch_end_6;
            branch_no_6:;
            {
                PyObject *tmp_ass_subvalue_2;
                PyObject *tmp_ass_subscribed_2;
                PyObject *tmp_source_name_5;
                PyObject *tmp_ass_subscript_2;
                CHECK_OBJECT( par_value );
                tmp_ass_subvalue_2 = par_value;
                CHECK_OBJECT( par_self );
                tmp_source_name_5 = par_self;
                tmp_ass_subscribed_2 = LOOKUP_ATTRIBUTE_DICT_SLOT( tmp_source_name_5 );
                if ( tmp_ass_subscribed_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 65;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_name );
                tmp_ass_subscript_2 = par_name;
                tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2 );
                Py_DECREF( tmp_ass_subscribed_2 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 65;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
            }
            branch_end_6:;
        }
        goto branch_end_5;
        branch_no_5:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_left_name_1 = const_str_digest_ae9f5c2d055786b8851c555eb34480de;
            CHECK_OBJECT( par_self );
            tmp_right_name_1 = par_self;
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 67;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_0c597563305462e9aa2ecc13cad43ab1->m_frame.f_lineno = 67;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 67;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        branch_end_5:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c597563305462e9aa2ecc13cad43ab1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c597563305462e9aa2ecc13cad43ab1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c597563305462e9aa2ecc13cad43ab1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c597563305462e9aa2ecc13cad43ab1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c597563305462e9aa2ecc13cad43ab1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c597563305462e9aa2ecc13cad43ab1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c597563305462e9aa2ecc13cad43ab1,
        type_description_1,
        par_self,
        par_class_type,
        par_name,
        par_value,
        par_static,
        var_method
    );


    // Release cached frame.
    if ( frame_0c597563305462e9aa2ecc13cad43ab1 == cache_frame_0c597563305462e9aa2ecc13cad43ab1 )
    {
        Py_DECREF( frame_0c597563305462e9aa2ecc13cad43ab1 );
    }
    cache_frame_0c597563305462e9aa2ecc13cad43ab1 = NULL;

    assertFrameObject( frame_0c597563305462e9aa2ecc13cad43ab1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_3__swig_setattr_nondynamic );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_class_type );
    Py_DECREF( par_class_type );
    par_class_type = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_static );
    Py_DECREF( par_static );
    par_static = NULL;

    Py_XDECREF( var_method );
    var_method = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_class_type );
    Py_DECREF( par_class_type );
    par_class_type = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_static );
    Py_DECREF( par_static );
    par_static = NULL;

    Py_XDECREF( var_method );
    var_method = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_3__swig_setattr_nondynamic );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_4__swig_setattr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_class_type = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *par_value = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_31d62ac91c511fe21d095de46eb92ef7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_31d62ac91c511fe21d095de46eb92ef7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_31d62ac91c511fe21d095de46eb92ef7, codeobj_31d62ac91c511fe21d095de46eb92ef7, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_31d62ac91c511fe21d095de46eb92ef7 = cache_frame_31d62ac91c511fe21d095de46eb92ef7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_31d62ac91c511fe21d095de46eb92ef7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_31d62ac91c511fe21d095de46eb92ef7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_setattr_nondynamic );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__swig_setattr_nondynamic );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_swig_setattr_nondynamic" );
            exception_tb = NULL;

            exception_lineno = 71;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_class_type );
        tmp_args_element_name_2 = par_class_type;
        CHECK_OBJECT( par_name );
        tmp_args_element_name_3 = par_name;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_4 = par_value;
        tmp_args_element_name_5 = const_int_0;
        frame_31d62ac91c511fe21d095de46eb92ef7->m_frame.f_lineno = 71;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 71;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31d62ac91c511fe21d095de46eb92ef7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_31d62ac91c511fe21d095de46eb92ef7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31d62ac91c511fe21d095de46eb92ef7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_31d62ac91c511fe21d095de46eb92ef7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_31d62ac91c511fe21d095de46eb92ef7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_31d62ac91c511fe21d095de46eb92ef7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31d62ac91c511fe21d095de46eb92ef7,
        type_description_1,
        par_self,
        par_class_type,
        par_name,
        par_value
    );


    // Release cached frame.
    if ( frame_31d62ac91c511fe21d095de46eb92ef7 == cache_frame_31d62ac91c511fe21d095de46eb92ef7 )
    {
        Py_DECREF( frame_31d62ac91c511fe21d095de46eb92ef7 );
    }
    cache_frame_31d62ac91c511fe21d095de46eb92ef7 = NULL;

    assertFrameObject( frame_31d62ac91c511fe21d095de46eb92ef7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_4__swig_setattr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_class_type );
    Py_DECREF( par_class_type );
    par_class_type = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_class_type );
    Py_DECREF( par_class_type );
    par_class_type = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_4__swig_setattr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_5__swig_getattr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_class_type = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *var_method = NULL;
    struct Nuitka_FrameObject *frame_ba9b8ae61fe4bb523340e957b1f4e083;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ba9b8ae61fe4bb523340e957b1f4e083 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ba9b8ae61fe4bb523340e957b1f4e083, codeobj_ba9b8ae61fe4bb523340e957b1f4e083, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ba9b8ae61fe4bb523340e957b1f4e083 = cache_frame_ba9b8ae61fe4bb523340e957b1f4e083;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ba9b8ae61fe4bb523340e957b1f4e083 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ba9b8ae61fe4bb523340e957b1f4e083 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_1 = par_name;
        tmp_compexpr_right_1 = const_str_plain_thisown;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 75;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_this );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 76;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_ba9b8ae61fe4bb523340e957b1f4e083->m_frame.f_lineno = 76;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_own );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 76;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_class_type );
        tmp_source_name_2 = par_class_type;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___swig_getmethods__ );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 77;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_args_element_name_1 = par_name;
        tmp_args_element_name_2 = Py_None;
        frame_ba9b8ae61fe4bb523340e957b1f4e083->m_frame.f_lineno = 77;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_get, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 77;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_method == NULL );
        var_method = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_method );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_method );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( var_method );
            tmp_called_name_1 = var_method;
            CHECK_OBJECT( par_self );
            tmp_args_element_name_3 = par_self;
            frame_ba9b8ae61fe4bb523340e957b1f4e083->m_frame.f_lineno = 79;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 79;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_3;
        tmp_left_name_1 = const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
        CHECK_OBJECT( par_class_type );
        tmp_source_name_3 = par_class_type;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___name__ );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 80;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 80;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_ba9b8ae61fe4bb523340e957b1f4e083->m_frame.f_lineno = 80;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 80;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ba9b8ae61fe4bb523340e957b1f4e083 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ba9b8ae61fe4bb523340e957b1f4e083 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ba9b8ae61fe4bb523340e957b1f4e083 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ba9b8ae61fe4bb523340e957b1f4e083, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ba9b8ae61fe4bb523340e957b1f4e083->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ba9b8ae61fe4bb523340e957b1f4e083, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ba9b8ae61fe4bb523340e957b1f4e083,
        type_description_1,
        par_self,
        par_class_type,
        par_name,
        var_method
    );


    // Release cached frame.
    if ( frame_ba9b8ae61fe4bb523340e957b1f4e083 == cache_frame_ba9b8ae61fe4bb523340e957b1f4e083 )
    {
        Py_DECREF( frame_ba9b8ae61fe4bb523340e957b1f4e083 );
    }
    cache_frame_ba9b8ae61fe4bb523340e957b1f4e083 = NULL;

    assertFrameObject( frame_ba9b8ae61fe4bb523340e957b1f4e083 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_5__swig_getattr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_method );
    var_method = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_class_type );
    Py_DECREF( par_class_type );
    par_class_type = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_method );
    var_method = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_class_type );
    Py_DECREF( par_class_type );
    par_class_type = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_5__swig_getattr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_6__swig_repr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_strthis = NULL;
    struct Nuitka_FrameObject *frame_9d7f64f4db8767f12bf73f9bbb96e593;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9d7f64f4db8767f12bf73f9bbb96e593 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9d7f64f4db8767f12bf73f9bbb96e593, codeobj_9d7f64f4db8767f12bf73f9bbb96e593, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_9d7f64f4db8767f12bf73f9bbb96e593 = cache_frame_9d7f64f4db8767f12bf73f9bbb96e593;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9d7f64f4db8767f12bf73f9bbb96e593 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9d7f64f4db8767f12bf73f9bbb96e593 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        tmp_left_name_1 = const_str_digest_07348ad52202465dc552f2bfab430ac3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_this );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 85;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        frame_9d7f64f4db8767f12bf73f9bbb96e593->m_frame.f_lineno = 85;
        tmp_right_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain___repr__ );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 85;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_assign_source_1 = BINARY_OPERATION_ADD_STR_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 85;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        assert( var_strthis == NULL );
        var_strthis = tmp_assign_source_1;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_9d7f64f4db8767f12bf73f9bbb96e593 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_9d7f64f4db8767f12bf73f9bbb96e593, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_9d7f64f4db8767f12bf73f9bbb96e593, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___builtin__ );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___builtin__ );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__builtin__" );
            exception_tb = NULL;

            exception_lineno = 86;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_Exception );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 86;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 86;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = const_str_empty;
            assert( var_strthis == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_strthis = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 84;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_9d7f64f4db8767f12bf73f9bbb96e593->m_frame) frame_9d7f64f4db8767f12bf73f9bbb96e593->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_6__swig_repr );
    return NULL;
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        tmp_left_name_2 = const_str_digest_44a910c126961a21fb78c77a5e30433a;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_4 );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 88;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___module__ );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 88;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = PyTuple_New( 3 );
        PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_source_name_5 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_6 );
        if ( tmp_source_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_2 );

            exception_lineno = 88;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___name__ );
        Py_DECREF( tmp_source_name_5 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_right_name_2 );

            exception_lineno = 88;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_1 );
        if ( var_strthis == NULL )
        {
            Py_DECREF( tmp_right_name_2 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "strthis" );
            exception_tb = NULL;

            exception_lineno = 88;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = var_strthis;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_right_name_2, 2, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 88;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_9d7f64f4db8767f12bf73f9bbb96e593 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_9d7f64f4db8767f12bf73f9bbb96e593 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_9d7f64f4db8767f12bf73f9bbb96e593 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9d7f64f4db8767f12bf73f9bbb96e593, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9d7f64f4db8767f12bf73f9bbb96e593->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9d7f64f4db8767f12bf73f9bbb96e593, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9d7f64f4db8767f12bf73f9bbb96e593,
        type_description_1,
        par_self,
        var_strthis
    );


    // Release cached frame.
    if ( frame_9d7f64f4db8767f12bf73f9bbb96e593 == cache_frame_9d7f64f4db8767f12bf73f9bbb96e593 )
    {
        Py_DECREF( frame_9d7f64f4db8767f12bf73f9bbb96e593 );
    }
    cache_frame_9d7f64f4db8767f12bf73f9bbb96e593 = NULL;

    assertFrameObject( frame_9d7f64f4db8767f12bf73f9bbb96e593 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_6__swig_repr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_strthis );
    var_strthis = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_strthis );
    var_strthis = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_6__swig_repr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_7_libpd_clear_search_path( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_343b5115a46b045f2a2143c29663c2cf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_343b5115a46b045f2a2143c29663c2cf = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME( cache_frame_343b5115a46b045f2a2143c29663c2cf, codeobj_343b5115a46b045f2a2143c29663c2cf, module_pylibpd, 0 );
    frame_343b5115a46b045f2a2143c29663c2cf = cache_frame_343b5115a46b045f2a2143c29663c2cf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_343b5115a46b045f2a2143c29663c2cf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_343b5115a46b045f2a2143c29663c2cf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 100;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_343b5115a46b045f2a2143c29663c2cf->m_frame.f_lineno = 100;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_libpd_clear_search_path );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;

            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_343b5115a46b045f2a2143c29663c2cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_343b5115a46b045f2a2143c29663c2cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_343b5115a46b045f2a2143c29663c2cf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_343b5115a46b045f2a2143c29663c2cf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_343b5115a46b045f2a2143c29663c2cf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_343b5115a46b045f2a2143c29663c2cf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_343b5115a46b045f2a2143c29663c2cf,
        type_description_1
    );


    // Release cached frame.
    if ( frame_343b5115a46b045f2a2143c29663c2cf == cache_frame_343b5115a46b045f2a2143c29663c2cf )
    {
        Py_DECREF( frame_343b5115a46b045f2a2143c29663c2cf );
    }
    cache_frame_343b5115a46b045f2a2143c29663c2cf = NULL;

    assertFrameObject( frame_343b5115a46b045f2a2143c29663c2cf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_7_libpd_clear_search_path );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_8_libpd_add_to_search_path( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dir = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0aefc78e9fc9d2a532bc1b9369744774;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0aefc78e9fc9d2a532bc1b9369744774 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0aefc78e9fc9d2a532bc1b9369744774, codeobj_0aefc78e9fc9d2a532bc1b9369744774, module_pylibpd, sizeof(void *) );
    frame_0aefc78e9fc9d2a532bc1b9369744774 = cache_frame_0aefc78e9fc9d2a532bc1b9369744774;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0aefc78e9fc9d2a532bc1b9369744774 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0aefc78e9fc9d2a532bc1b9369744774 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 104;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_dir );
        tmp_args_element_name_1 = par_dir;
        frame_0aefc78e9fc9d2a532bc1b9369744774->m_frame.f_lineno = 104;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_add_to_search_path, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 104;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0aefc78e9fc9d2a532bc1b9369744774 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0aefc78e9fc9d2a532bc1b9369744774 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0aefc78e9fc9d2a532bc1b9369744774 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0aefc78e9fc9d2a532bc1b9369744774, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0aefc78e9fc9d2a532bc1b9369744774->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0aefc78e9fc9d2a532bc1b9369744774, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0aefc78e9fc9d2a532bc1b9369744774,
        type_description_1,
        par_dir
    );


    // Release cached frame.
    if ( frame_0aefc78e9fc9d2a532bc1b9369744774 == cache_frame_0aefc78e9fc9d2a532bc1b9369744774 )
    {
        Py_DECREF( frame_0aefc78e9fc9d2a532bc1b9369744774 );
    }
    cache_frame_0aefc78e9fc9d2a532bc1b9369744774 = NULL;

    assertFrameObject( frame_0aefc78e9fc9d2a532bc1b9369744774 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_8_libpd_add_to_search_path );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dir );
    Py_DECREF( par_dir );
    par_dir = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dir );
    Py_DECREF( par_dir );
    par_dir = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_8_libpd_add_to_search_path );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_9_libpd_blocksize( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_acf27e75a7097025445ee5215c567823;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_acf27e75a7097025445ee5215c567823 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME( cache_frame_acf27e75a7097025445ee5215c567823, codeobj_acf27e75a7097025445ee5215c567823, module_pylibpd, 0 );
    frame_acf27e75a7097025445ee5215c567823 = cache_frame_acf27e75a7097025445ee5215c567823;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_acf27e75a7097025445ee5215c567823 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_acf27e75a7097025445ee5215c567823 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 108;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_acf27e75a7097025445ee5215c567823->m_frame.f_lineno = 108;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_libpd_blocksize );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 108;

            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acf27e75a7097025445ee5215c567823 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_acf27e75a7097025445ee5215c567823 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_acf27e75a7097025445ee5215c567823 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_acf27e75a7097025445ee5215c567823, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_acf27e75a7097025445ee5215c567823->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_acf27e75a7097025445ee5215c567823, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_acf27e75a7097025445ee5215c567823,
        type_description_1
    );


    // Release cached frame.
    if ( frame_acf27e75a7097025445ee5215c567823 == cache_frame_acf27e75a7097025445ee5215c567823 )
    {
        Py_DECREF( frame_acf27e75a7097025445ee5215c567823 );
    }
    cache_frame_acf27e75a7097025445ee5215c567823 = NULL;

    assertFrameObject( frame_acf27e75a7097025445ee5215c567823 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_9_libpd_blocksize );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_10_libpd_init_audio( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_inch = python_pars[ 0 ];
    PyObject *par_outch = python_pars[ 1 ];
    PyObject *par_srate = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_3504f5a87d2a4feec5f4942b8d92c36d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3504f5a87d2a4feec5f4942b8d92c36d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3504f5a87d2a4feec5f4942b8d92c36d, codeobj_3504f5a87d2a4feec5f4942b8d92c36d, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3504f5a87d2a4feec5f4942b8d92c36d = cache_frame_3504f5a87d2a4feec5f4942b8d92c36d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3504f5a87d2a4feec5f4942b8d92c36d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3504f5a87d2a4feec5f4942b8d92c36d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 112;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_inch );
        tmp_args_element_name_1 = par_inch;
        CHECK_OBJECT( par_outch );
        tmp_args_element_name_2 = par_outch;
        CHECK_OBJECT( par_srate );
        tmp_args_element_name_3 = par_srate;
        frame_3504f5a87d2a4feec5f4942b8d92c36d->m_frame.f_lineno = 112;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_init_audio, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 112;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3504f5a87d2a4feec5f4942b8d92c36d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3504f5a87d2a4feec5f4942b8d92c36d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3504f5a87d2a4feec5f4942b8d92c36d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3504f5a87d2a4feec5f4942b8d92c36d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3504f5a87d2a4feec5f4942b8d92c36d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3504f5a87d2a4feec5f4942b8d92c36d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3504f5a87d2a4feec5f4942b8d92c36d,
        type_description_1,
        par_inch,
        par_outch,
        par_srate
    );


    // Release cached frame.
    if ( frame_3504f5a87d2a4feec5f4942b8d92c36d == cache_frame_3504f5a87d2a4feec5f4942b8d92c36d )
    {
        Py_DECREF( frame_3504f5a87d2a4feec5f4942b8d92c36d );
    }
    cache_frame_3504f5a87d2a4feec5f4942b8d92c36d = NULL;

    assertFrameObject( frame_3504f5a87d2a4feec5f4942b8d92c36d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_10_libpd_init_audio );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_inch );
    Py_DECREF( par_inch );
    par_inch = NULL;

    CHECK_OBJECT( (PyObject *)par_outch );
    Py_DECREF( par_outch );
    par_outch = NULL;

    CHECK_OBJECT( (PyObject *)par_srate );
    Py_DECREF( par_srate );
    par_srate = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_inch );
    Py_DECREF( par_inch );
    par_inch = NULL;

    CHECK_OBJECT( (PyObject *)par_outch );
    Py_DECREF( par_outch );
    par_outch = NULL;

    CHECK_OBJECT( (PyObject *)par_srate );
    Py_DECREF( par_srate );
    par_srate = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_10_libpd_init_audio );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_11_libpd_process_raw( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_inb = python_pars[ 0 ];
    PyObject *par_outb = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_6a0ddd42e1b7a5a4152a4240159ad237;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6a0ddd42e1b7a5a4152a4240159ad237 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a0ddd42e1b7a5a4152a4240159ad237, codeobj_6a0ddd42e1b7a5a4152a4240159ad237, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_6a0ddd42e1b7a5a4152a4240159ad237 = cache_frame_6a0ddd42e1b7a5a4152a4240159ad237;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a0ddd42e1b7a5a4152a4240159ad237 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a0ddd42e1b7a5a4152a4240159ad237 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 116;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_inb );
        tmp_args_element_name_1 = par_inb;
        CHECK_OBJECT( par_outb );
        tmp_args_element_name_2 = par_outb;
        frame_6a0ddd42e1b7a5a4152a4240159ad237->m_frame.f_lineno = 116;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_process_raw, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 116;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a0ddd42e1b7a5a4152a4240159ad237 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a0ddd42e1b7a5a4152a4240159ad237 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a0ddd42e1b7a5a4152a4240159ad237 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a0ddd42e1b7a5a4152a4240159ad237, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a0ddd42e1b7a5a4152a4240159ad237->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a0ddd42e1b7a5a4152a4240159ad237, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a0ddd42e1b7a5a4152a4240159ad237,
        type_description_1,
        par_inb,
        par_outb
    );


    // Release cached frame.
    if ( frame_6a0ddd42e1b7a5a4152a4240159ad237 == cache_frame_6a0ddd42e1b7a5a4152a4240159ad237 )
    {
        Py_DECREF( frame_6a0ddd42e1b7a5a4152a4240159ad237 );
    }
    cache_frame_6a0ddd42e1b7a5a4152a4240159ad237 = NULL;

    assertFrameObject( frame_6a0ddd42e1b7a5a4152a4240159ad237 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_11_libpd_process_raw );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_11_libpd_process_raw );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_12_libpd_process_float( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ticks = python_pars[ 0 ];
    PyObject *par_inb = python_pars[ 1 ];
    PyObject *par_outb = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_ac4c9fe1769bc11600950c3944287e34;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ac4c9fe1769bc11600950c3944287e34 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ac4c9fe1769bc11600950c3944287e34, codeobj_ac4c9fe1769bc11600950c3944287e34, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ac4c9fe1769bc11600950c3944287e34 = cache_frame_ac4c9fe1769bc11600950c3944287e34;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ac4c9fe1769bc11600950c3944287e34 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ac4c9fe1769bc11600950c3944287e34 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 120;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ticks );
        tmp_args_element_name_1 = par_ticks;
        CHECK_OBJECT( par_inb );
        tmp_args_element_name_2 = par_inb;
        CHECK_OBJECT( par_outb );
        tmp_args_element_name_3 = par_outb;
        frame_ac4c9fe1769bc11600950c3944287e34->m_frame.f_lineno = 120;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_process_float, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 120;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac4c9fe1769bc11600950c3944287e34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac4c9fe1769bc11600950c3944287e34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac4c9fe1769bc11600950c3944287e34 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ac4c9fe1769bc11600950c3944287e34, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ac4c9fe1769bc11600950c3944287e34->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ac4c9fe1769bc11600950c3944287e34, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ac4c9fe1769bc11600950c3944287e34,
        type_description_1,
        par_ticks,
        par_inb,
        par_outb
    );


    // Release cached frame.
    if ( frame_ac4c9fe1769bc11600950c3944287e34 == cache_frame_ac4c9fe1769bc11600950c3944287e34 )
    {
        Py_DECREF( frame_ac4c9fe1769bc11600950c3944287e34 );
    }
    cache_frame_ac4c9fe1769bc11600950c3944287e34 = NULL;

    assertFrameObject( frame_ac4c9fe1769bc11600950c3944287e34 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_12_libpd_process_float );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_12_libpd_process_float );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_13_libpd_process_short( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ticks = python_pars[ 0 ];
    PyObject *par_inb = python_pars[ 1 ];
    PyObject *par_outb = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_e3b16727cdeb05738c4c9320beae9d9b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e3b16727cdeb05738c4c9320beae9d9b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e3b16727cdeb05738c4c9320beae9d9b, codeobj_e3b16727cdeb05738c4c9320beae9d9b, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e3b16727cdeb05738c4c9320beae9d9b = cache_frame_e3b16727cdeb05738c4c9320beae9d9b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e3b16727cdeb05738c4c9320beae9d9b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e3b16727cdeb05738c4c9320beae9d9b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ticks );
        tmp_args_element_name_1 = par_ticks;
        CHECK_OBJECT( par_inb );
        tmp_args_element_name_2 = par_inb;
        CHECK_OBJECT( par_outb );
        tmp_args_element_name_3 = par_outb;
        frame_e3b16727cdeb05738c4c9320beae9d9b->m_frame.f_lineno = 124;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_process_short, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3b16727cdeb05738c4c9320beae9d9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3b16727cdeb05738c4c9320beae9d9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e3b16727cdeb05738c4c9320beae9d9b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e3b16727cdeb05738c4c9320beae9d9b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e3b16727cdeb05738c4c9320beae9d9b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e3b16727cdeb05738c4c9320beae9d9b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e3b16727cdeb05738c4c9320beae9d9b,
        type_description_1,
        par_ticks,
        par_inb,
        par_outb
    );


    // Release cached frame.
    if ( frame_e3b16727cdeb05738c4c9320beae9d9b == cache_frame_e3b16727cdeb05738c4c9320beae9d9b )
    {
        Py_DECREF( frame_e3b16727cdeb05738c4c9320beae9d9b );
    }
    cache_frame_e3b16727cdeb05738c4c9320beae9d9b = NULL;

    assertFrameObject( frame_e3b16727cdeb05738c4c9320beae9d9b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_13_libpd_process_short );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_13_libpd_process_short );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_14_libpd_process_double( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ticks = python_pars[ 0 ];
    PyObject *par_inb = python_pars[ 1 ];
    PyObject *par_outb = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_0cb4bd587a57e70362d1db49a3a5990f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0cb4bd587a57e70362d1db49a3a5990f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0cb4bd587a57e70362d1db49a3a5990f, codeobj_0cb4bd587a57e70362d1db49a3a5990f, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0cb4bd587a57e70362d1db49a3a5990f = cache_frame_0cb4bd587a57e70362d1db49a3a5990f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0cb4bd587a57e70362d1db49a3a5990f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0cb4bd587a57e70362d1db49a3a5990f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 128;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ticks );
        tmp_args_element_name_1 = par_ticks;
        CHECK_OBJECT( par_inb );
        tmp_args_element_name_2 = par_inb;
        CHECK_OBJECT( par_outb );
        tmp_args_element_name_3 = par_outb;
        frame_0cb4bd587a57e70362d1db49a3a5990f->m_frame.f_lineno = 128;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_process_double, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 128;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0cb4bd587a57e70362d1db49a3a5990f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0cb4bd587a57e70362d1db49a3a5990f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0cb4bd587a57e70362d1db49a3a5990f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0cb4bd587a57e70362d1db49a3a5990f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0cb4bd587a57e70362d1db49a3a5990f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0cb4bd587a57e70362d1db49a3a5990f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0cb4bd587a57e70362d1db49a3a5990f,
        type_description_1,
        par_ticks,
        par_inb,
        par_outb
    );


    // Release cached frame.
    if ( frame_0cb4bd587a57e70362d1db49a3a5990f == cache_frame_0cb4bd587a57e70362d1db49a3a5990f )
    {
        Py_DECREF( frame_0cb4bd587a57e70362d1db49a3a5990f );
    }
    cache_frame_0cb4bd587a57e70362d1db49a3a5990f = NULL;

    assertFrameObject( frame_0cb4bd587a57e70362d1db49a3a5990f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_14_libpd_process_double );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_14_libpd_process_double );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_15_libpd_arraysize( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_071a47a91f9aed57f315c24786e5f01c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_071a47a91f9aed57f315c24786e5f01c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_071a47a91f9aed57f315c24786e5f01c, codeobj_071a47a91f9aed57f315c24786e5f01c, module_pylibpd, sizeof(void *) );
    frame_071a47a91f9aed57f315c24786e5f01c = cache_frame_071a47a91f9aed57f315c24786e5f01c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_071a47a91f9aed57f315c24786e5f01c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_071a47a91f9aed57f315c24786e5f01c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_name );
        tmp_args_element_name_1 = par_name;
        frame_071a47a91f9aed57f315c24786e5f01c->m_frame.f_lineno = 132;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_arraysize, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_071a47a91f9aed57f315c24786e5f01c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_071a47a91f9aed57f315c24786e5f01c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_071a47a91f9aed57f315c24786e5f01c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_071a47a91f9aed57f315c24786e5f01c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_071a47a91f9aed57f315c24786e5f01c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_071a47a91f9aed57f315c24786e5f01c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_071a47a91f9aed57f315c24786e5f01c,
        type_description_1,
        par_name
    );


    // Release cached frame.
    if ( frame_071a47a91f9aed57f315c24786e5f01c == cache_frame_071a47a91f9aed57f315c24786e5f01c )
    {
        Py_DECREF( frame_071a47a91f9aed57f315c24786e5f01c );
    }
    cache_frame_071a47a91f9aed57f315c24786e5f01c = NULL;

    assertFrameObject( frame_071a47a91f9aed57f315c24786e5f01c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_15_libpd_arraysize );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_15_libpd_arraysize );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_16_libpd_read_array( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_outb = python_pars[ 0 ];
    PyObject *par_src = python_pars[ 1 ];
    PyObject *par_offset = python_pars[ 2 ];
    PyObject *par_n = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_6c62e24c2138b71b7592c5ef03e03f2e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6c62e24c2138b71b7592c5ef03e03f2e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6c62e24c2138b71b7592c5ef03e03f2e, codeobj_6c62e24c2138b71b7592c5ef03e03f2e, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6c62e24c2138b71b7592c5ef03e03f2e = cache_frame_6c62e24c2138b71b7592c5ef03e03f2e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6c62e24c2138b71b7592c5ef03e03f2e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6c62e24c2138b71b7592c5ef03e03f2e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_outb );
        tmp_args_element_name_1 = par_outb;
        CHECK_OBJECT( par_src );
        tmp_args_element_name_2 = par_src;
        CHECK_OBJECT( par_offset );
        tmp_args_element_name_3 = par_offset;
        CHECK_OBJECT( par_n );
        tmp_args_element_name_4 = par_n;
        frame_6c62e24c2138b71b7592c5ef03e03f2e->m_frame.f_lineno = 136;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_return_value = CALL_METHOD_WITH_ARGS4( tmp_called_instance_1, const_str_plain_libpd_read_array, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c62e24c2138b71b7592c5ef03e03f2e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c62e24c2138b71b7592c5ef03e03f2e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c62e24c2138b71b7592c5ef03e03f2e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6c62e24c2138b71b7592c5ef03e03f2e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6c62e24c2138b71b7592c5ef03e03f2e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6c62e24c2138b71b7592c5ef03e03f2e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6c62e24c2138b71b7592c5ef03e03f2e,
        type_description_1,
        par_outb,
        par_src,
        par_offset,
        par_n
    );


    // Release cached frame.
    if ( frame_6c62e24c2138b71b7592c5ef03e03f2e == cache_frame_6c62e24c2138b71b7592c5ef03e03f2e )
    {
        Py_DECREF( frame_6c62e24c2138b71b7592c5ef03e03f2e );
    }
    cache_frame_6c62e24c2138b71b7592c5ef03e03f2e = NULL;

    assertFrameObject( frame_6c62e24c2138b71b7592c5ef03e03f2e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_16_libpd_read_array );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_src );
    Py_DECREF( par_src );
    par_src = NULL;

    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    CHECK_OBJECT( (PyObject *)par_offset );
    Py_DECREF( par_offset );
    par_offset = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_src );
    Py_DECREF( par_src );
    par_src = NULL;

    CHECK_OBJECT( (PyObject *)par_outb );
    Py_DECREF( par_outb );
    par_outb = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    CHECK_OBJECT( (PyObject *)par_offset );
    Py_DECREF( par_offset );
    par_offset = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_16_libpd_read_array );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_17_libpd_write_array( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dest = python_pars[ 0 ];
    PyObject *par_offset = python_pars[ 1 ];
    PyObject *par_inb = python_pars[ 2 ];
    PyObject *par_n = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_7488e77d04da376327f8b18b5284652a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7488e77d04da376327f8b18b5284652a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7488e77d04da376327f8b18b5284652a, codeobj_7488e77d04da376327f8b18b5284652a, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7488e77d04da376327f8b18b5284652a = cache_frame_7488e77d04da376327f8b18b5284652a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7488e77d04da376327f8b18b5284652a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7488e77d04da376327f8b18b5284652a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 140;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_dest );
        tmp_args_element_name_1 = par_dest;
        CHECK_OBJECT( par_offset );
        tmp_args_element_name_2 = par_offset;
        CHECK_OBJECT( par_inb );
        tmp_args_element_name_3 = par_inb;
        CHECK_OBJECT( par_n );
        tmp_args_element_name_4 = par_n;
        frame_7488e77d04da376327f8b18b5284652a->m_frame.f_lineno = 140;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_return_value = CALL_METHOD_WITH_ARGS4( tmp_called_instance_1, const_str_plain_libpd_write_array, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 140;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7488e77d04da376327f8b18b5284652a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7488e77d04da376327f8b18b5284652a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7488e77d04da376327f8b18b5284652a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7488e77d04da376327f8b18b5284652a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7488e77d04da376327f8b18b5284652a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7488e77d04da376327f8b18b5284652a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7488e77d04da376327f8b18b5284652a,
        type_description_1,
        par_dest,
        par_offset,
        par_inb,
        par_n
    );


    // Release cached frame.
    if ( frame_7488e77d04da376327f8b18b5284652a == cache_frame_7488e77d04da376327f8b18b5284652a )
    {
        Py_DECREF( frame_7488e77d04da376327f8b18b5284652a );
    }
    cache_frame_7488e77d04da376327f8b18b5284652a = NULL;

    assertFrameObject( frame_7488e77d04da376327f8b18b5284652a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_17_libpd_write_array );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    CHECK_OBJECT( (PyObject *)par_offset );
    Py_DECREF( par_offset );
    par_offset = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    CHECK_OBJECT( (PyObject *)par_inb );
    Py_DECREF( par_inb );
    par_inb = NULL;

    CHECK_OBJECT( (PyObject *)par_offset );
    Py_DECREF( par_offset );
    par_offset = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_17_libpd_write_array );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_18_libpd_bang( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dest = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2f2ef16995e2a75890649eda2fadfb87;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2f2ef16995e2a75890649eda2fadfb87 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f2ef16995e2a75890649eda2fadfb87, codeobj_2f2ef16995e2a75890649eda2fadfb87, module_pylibpd, sizeof(void *) );
    frame_2f2ef16995e2a75890649eda2fadfb87 = cache_frame_2f2ef16995e2a75890649eda2fadfb87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f2ef16995e2a75890649eda2fadfb87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f2ef16995e2a75890649eda2fadfb87 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 144;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_dest );
        tmp_args_element_name_1 = par_dest;
        frame_2f2ef16995e2a75890649eda2fadfb87->m_frame.f_lineno = 144;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_bang, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 144;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f2ef16995e2a75890649eda2fadfb87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f2ef16995e2a75890649eda2fadfb87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f2ef16995e2a75890649eda2fadfb87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f2ef16995e2a75890649eda2fadfb87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f2ef16995e2a75890649eda2fadfb87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f2ef16995e2a75890649eda2fadfb87, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f2ef16995e2a75890649eda2fadfb87,
        type_description_1,
        par_dest
    );


    // Release cached frame.
    if ( frame_2f2ef16995e2a75890649eda2fadfb87 == cache_frame_2f2ef16995e2a75890649eda2fadfb87 )
    {
        Py_DECREF( frame_2f2ef16995e2a75890649eda2fadfb87 );
    }
    cache_frame_2f2ef16995e2a75890649eda2fadfb87 = NULL;

    assertFrameObject( frame_2f2ef16995e2a75890649eda2fadfb87 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_18_libpd_bang );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_18_libpd_bang );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_19_libpd_float( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dest = python_pars[ 0 ];
    PyObject *par_val = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_e8f21a19af2747cccbab902149f03067;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e8f21a19af2747cccbab902149f03067 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e8f21a19af2747cccbab902149f03067, codeobj_e8f21a19af2747cccbab902149f03067, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_e8f21a19af2747cccbab902149f03067 = cache_frame_e8f21a19af2747cccbab902149f03067;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e8f21a19af2747cccbab902149f03067 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e8f21a19af2747cccbab902149f03067 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 148;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_dest );
        tmp_args_element_name_1 = par_dest;
        CHECK_OBJECT( par_val );
        tmp_args_element_name_2 = par_val;
        frame_e8f21a19af2747cccbab902149f03067->m_frame.f_lineno = 148;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_float, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 148;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8f21a19af2747cccbab902149f03067 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8f21a19af2747cccbab902149f03067 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e8f21a19af2747cccbab902149f03067 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e8f21a19af2747cccbab902149f03067, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e8f21a19af2747cccbab902149f03067->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e8f21a19af2747cccbab902149f03067, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e8f21a19af2747cccbab902149f03067,
        type_description_1,
        par_dest,
        par_val
    );


    // Release cached frame.
    if ( frame_e8f21a19af2747cccbab902149f03067 == cache_frame_e8f21a19af2747cccbab902149f03067 )
    {
        Py_DECREF( frame_e8f21a19af2747cccbab902149f03067 );
    }
    cache_frame_e8f21a19af2747cccbab902149f03067 = NULL;

    assertFrameObject( frame_e8f21a19af2747cccbab902149f03067 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_19_libpd_float );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_val );
    Py_DECREF( par_val );
    par_val = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_val );
    Py_DECREF( par_val );
    par_val = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_19_libpd_float );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_20_libpd_symbol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dest = python_pars[ 0 ];
    PyObject *par_sym = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_cf2a7fe516656bccd925f44e5df336e1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cf2a7fe516656bccd925f44e5df336e1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cf2a7fe516656bccd925f44e5df336e1, codeobj_cf2a7fe516656bccd925f44e5df336e1, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_cf2a7fe516656bccd925f44e5df336e1 = cache_frame_cf2a7fe516656bccd925f44e5df336e1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cf2a7fe516656bccd925f44e5df336e1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cf2a7fe516656bccd925f44e5df336e1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 152;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_dest );
        tmp_args_element_name_1 = par_dest;
        CHECK_OBJECT( par_sym );
        tmp_args_element_name_2 = par_sym;
        frame_cf2a7fe516656bccd925f44e5df336e1->m_frame.f_lineno = 152;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_symbol, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf2a7fe516656bccd925f44e5df336e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf2a7fe516656bccd925f44e5df336e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf2a7fe516656bccd925f44e5df336e1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cf2a7fe516656bccd925f44e5df336e1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cf2a7fe516656bccd925f44e5df336e1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cf2a7fe516656bccd925f44e5df336e1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf2a7fe516656bccd925f44e5df336e1,
        type_description_1,
        par_dest,
        par_sym
    );


    // Release cached frame.
    if ( frame_cf2a7fe516656bccd925f44e5df336e1 == cache_frame_cf2a7fe516656bccd925f44e5df336e1 )
    {
        Py_DECREF( frame_cf2a7fe516656bccd925f44e5df336e1 );
    }
    cache_frame_cf2a7fe516656bccd925f44e5df336e1 = NULL;

    assertFrameObject( frame_cf2a7fe516656bccd925f44e5df336e1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_20_libpd_symbol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_20_libpd_symbol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_21___libpd_start_message( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_97a2f5f9b43c1ac5b38cdffb015ad2e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_97a2f5f9b43c1ac5b38cdffb015ad2e3, codeobj_97a2f5f9b43c1ac5b38cdffb015ad2e3, module_pylibpd, sizeof(void *) );
    frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 = cache_frame_97a2f5f9b43c1ac5b38cdffb015ad2e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        frame_97a2f5f9b43c1ac5b38cdffb015ad2e3->m_frame.f_lineno = 156;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_start_message, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_97a2f5f9b43c1ac5b38cdffb015ad2e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_97a2f5f9b43c1ac5b38cdffb015ad2e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_97a2f5f9b43c1ac5b38cdffb015ad2e3,
        type_description_1,
        par_arg1
    );


    // Release cached frame.
    if ( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 == cache_frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 )
    {
        Py_DECREF( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 );
    }
    cache_frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 = NULL;

    assertFrameObject( frame_97a2f5f9b43c1ac5b38cdffb015ad2e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_21___libpd_start_message );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_21___libpd_start_message );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_22___libpd_add_float( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f8a670eef22f494443ea2b9e7952c907;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f8a670eef22f494443ea2b9e7952c907 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f8a670eef22f494443ea2b9e7952c907, codeobj_f8a670eef22f494443ea2b9e7952c907, module_pylibpd, sizeof(void *) );
    frame_f8a670eef22f494443ea2b9e7952c907 = cache_frame_f8a670eef22f494443ea2b9e7952c907;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f8a670eef22f494443ea2b9e7952c907 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f8a670eef22f494443ea2b9e7952c907 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 160;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        frame_f8a670eef22f494443ea2b9e7952c907->m_frame.f_lineno = 160;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_add_float, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 160;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8a670eef22f494443ea2b9e7952c907 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8a670eef22f494443ea2b9e7952c907 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8a670eef22f494443ea2b9e7952c907 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f8a670eef22f494443ea2b9e7952c907, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f8a670eef22f494443ea2b9e7952c907->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f8a670eef22f494443ea2b9e7952c907, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f8a670eef22f494443ea2b9e7952c907,
        type_description_1,
        par_arg1
    );


    // Release cached frame.
    if ( frame_f8a670eef22f494443ea2b9e7952c907 == cache_frame_f8a670eef22f494443ea2b9e7952c907 )
    {
        Py_DECREF( frame_f8a670eef22f494443ea2b9e7952c907 );
    }
    cache_frame_f8a670eef22f494443ea2b9e7952c907 = NULL;

    assertFrameObject( frame_f8a670eef22f494443ea2b9e7952c907 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_22___libpd_add_float );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_22___libpd_add_float );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_23___libpd_add_symbol( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9409a7b93d94702a4a69920ae04eb161;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9409a7b93d94702a4a69920ae04eb161 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9409a7b93d94702a4a69920ae04eb161, codeobj_9409a7b93d94702a4a69920ae04eb161, module_pylibpd, sizeof(void *) );
    frame_9409a7b93d94702a4a69920ae04eb161 = cache_frame_9409a7b93d94702a4a69920ae04eb161;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9409a7b93d94702a4a69920ae04eb161 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9409a7b93d94702a4a69920ae04eb161 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        frame_9409a7b93d94702a4a69920ae04eb161->m_frame.f_lineno = 164;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_add_symbol, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9409a7b93d94702a4a69920ae04eb161 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9409a7b93d94702a4a69920ae04eb161 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9409a7b93d94702a4a69920ae04eb161 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9409a7b93d94702a4a69920ae04eb161, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9409a7b93d94702a4a69920ae04eb161->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9409a7b93d94702a4a69920ae04eb161, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9409a7b93d94702a4a69920ae04eb161,
        type_description_1,
        par_arg1
    );


    // Release cached frame.
    if ( frame_9409a7b93d94702a4a69920ae04eb161 == cache_frame_9409a7b93d94702a4a69920ae04eb161 )
    {
        Py_DECREF( frame_9409a7b93d94702a4a69920ae04eb161 );
    }
    cache_frame_9409a7b93d94702a4a69920ae04eb161 = NULL;

    assertFrameObject( frame_9409a7b93d94702a4a69920ae04eb161 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_23___libpd_add_symbol );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_23___libpd_add_symbol );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_24___libpd_finish_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_172af12e7cacf671fefe4dc3cb40b952;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_172af12e7cacf671fefe4dc3cb40b952 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_172af12e7cacf671fefe4dc3cb40b952, codeobj_172af12e7cacf671fefe4dc3cb40b952, module_pylibpd, sizeof(void *) );
    frame_172af12e7cacf671fefe4dc3cb40b952 = cache_frame_172af12e7cacf671fefe4dc3cb40b952;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_172af12e7cacf671fefe4dc3cb40b952 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_172af12e7cacf671fefe4dc3cb40b952 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 168;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        frame_172af12e7cacf671fefe4dc3cb40b952->m_frame.f_lineno = 168;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_finish_list, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_172af12e7cacf671fefe4dc3cb40b952 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_172af12e7cacf671fefe4dc3cb40b952 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_172af12e7cacf671fefe4dc3cb40b952 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_172af12e7cacf671fefe4dc3cb40b952, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_172af12e7cacf671fefe4dc3cb40b952->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_172af12e7cacf671fefe4dc3cb40b952, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_172af12e7cacf671fefe4dc3cb40b952,
        type_description_1,
        par_arg1
    );


    // Release cached frame.
    if ( frame_172af12e7cacf671fefe4dc3cb40b952 == cache_frame_172af12e7cacf671fefe4dc3cb40b952 )
    {
        Py_DECREF( frame_172af12e7cacf671fefe4dc3cb40b952 );
    }
    cache_frame_172af12e7cacf671fefe4dc3cb40b952 = NULL;

    assertFrameObject( frame_172af12e7cacf671fefe4dc3cb40b952 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_24___libpd_finish_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_24___libpd_finish_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_25___libpd_finish_message( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_arg2 = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_08db12479674b55bb4e97286ce56e485;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_08db12479674b55bb4e97286ce56e485 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08db12479674b55bb4e97286ce56e485, codeobj_08db12479674b55bb4e97286ce56e485, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_08db12479674b55bb4e97286ce56e485 = cache_frame_08db12479674b55bb4e97286ce56e485;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08db12479674b55bb4e97286ce56e485 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08db12479674b55bb4e97286ce56e485 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 172;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        CHECK_OBJECT( par_arg2 );
        tmp_args_element_name_2 = par_arg2;
        frame_08db12479674b55bb4e97286ce56e485->m_frame.f_lineno = 172;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___libpd_finish_message, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 172;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08db12479674b55bb4e97286ce56e485 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_08db12479674b55bb4e97286ce56e485 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08db12479674b55bb4e97286ce56e485 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08db12479674b55bb4e97286ce56e485, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08db12479674b55bb4e97286ce56e485->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08db12479674b55bb4e97286ce56e485, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_08db12479674b55bb4e97286ce56e485,
        type_description_1,
        par_arg1,
        par_arg2
    );


    // Release cached frame.
    if ( frame_08db12479674b55bb4e97286ce56e485 == cache_frame_08db12479674b55bb4e97286ce56e485 )
    {
        Py_DECREF( frame_08db12479674b55bb4e97286ce56e485 );
    }
    cache_frame_08db12479674b55bb4e97286ce56e485 = NULL;

    assertFrameObject( frame_08db12479674b55bb4e97286ce56e485 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_25___libpd_finish_message );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_25___libpd_finish_message );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_26_libpd_exists( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_sym = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d855202678d0be3f91372ec10aaf0bba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d855202678d0be3f91372ec10aaf0bba = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d855202678d0be3f91372ec10aaf0bba, codeobj_d855202678d0be3f91372ec10aaf0bba, module_pylibpd, sizeof(void *) );
    frame_d855202678d0be3f91372ec10aaf0bba = cache_frame_d855202678d0be3f91372ec10aaf0bba;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d855202678d0be3f91372ec10aaf0bba );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d855202678d0be3f91372ec10aaf0bba ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 176;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_sym );
        tmp_args_element_name_1 = par_sym;
        frame_d855202678d0be3f91372ec10aaf0bba->m_frame.f_lineno = 176;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_exists, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 176;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d855202678d0be3f91372ec10aaf0bba );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d855202678d0be3f91372ec10aaf0bba );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d855202678d0be3f91372ec10aaf0bba );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d855202678d0be3f91372ec10aaf0bba, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d855202678d0be3f91372ec10aaf0bba->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d855202678d0be3f91372ec10aaf0bba, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d855202678d0be3f91372ec10aaf0bba,
        type_description_1,
        par_sym
    );


    // Release cached frame.
    if ( frame_d855202678d0be3f91372ec10aaf0bba == cache_frame_d855202678d0be3f91372ec10aaf0bba )
    {
        Py_DECREF( frame_d855202678d0be3f91372ec10aaf0bba );
    }
    cache_frame_d855202678d0be3f91372ec10aaf0bba = NULL;

    assertFrameObject( frame_d855202678d0be3f91372ec10aaf0bba );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_26_libpd_exists );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_26_libpd_exists );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_27___libpd_bind( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_sym = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_aca50b06b384550b93d83ce16d52d8bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_aca50b06b384550b93d83ce16d52d8bf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aca50b06b384550b93d83ce16d52d8bf, codeobj_aca50b06b384550b93d83ce16d52d8bf, module_pylibpd, sizeof(void *) );
    frame_aca50b06b384550b93d83ce16d52d8bf = cache_frame_aca50b06b384550b93d83ce16d52d8bf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aca50b06b384550b93d83ce16d52d8bf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aca50b06b384550b93d83ce16d52d8bf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_sym );
        tmp_args_element_name_1 = par_sym;
        frame_aca50b06b384550b93d83ce16d52d8bf->m_frame.f_lineno = 180;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_bind, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 180;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aca50b06b384550b93d83ce16d52d8bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_aca50b06b384550b93d83ce16d52d8bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aca50b06b384550b93d83ce16d52d8bf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aca50b06b384550b93d83ce16d52d8bf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aca50b06b384550b93d83ce16d52d8bf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aca50b06b384550b93d83ce16d52d8bf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aca50b06b384550b93d83ce16d52d8bf,
        type_description_1,
        par_sym
    );


    // Release cached frame.
    if ( frame_aca50b06b384550b93d83ce16d52d8bf == cache_frame_aca50b06b384550b93d83ce16d52d8bf )
    {
        Py_DECREF( frame_aca50b06b384550b93d83ce16d52d8bf );
    }
    cache_frame_aca50b06b384550b93d83ce16d52d8bf = NULL;

    assertFrameObject( frame_aca50b06b384550b93d83ce16d52d8bf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_27___libpd_bind );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_27___libpd_bind );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_28___libpd_unbind( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_p = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d29ead87806ceb2eb05c06e32cd27a0d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d29ead87806ceb2eb05c06e32cd27a0d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d29ead87806ceb2eb05c06e32cd27a0d, codeobj_d29ead87806ceb2eb05c06e32cd27a0d, module_pylibpd, sizeof(void *) );
    frame_d29ead87806ceb2eb05c06e32cd27a0d = cache_frame_d29ead87806ceb2eb05c06e32cd27a0d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d29ead87806ceb2eb05c06e32cd27a0d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d29ead87806ceb2eb05c06e32cd27a0d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 184;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_p );
        tmp_args_element_name_1 = par_p;
        frame_d29ead87806ceb2eb05c06e32cd27a0d->m_frame.f_lineno = 184;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_unbind, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 184;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d29ead87806ceb2eb05c06e32cd27a0d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d29ead87806ceb2eb05c06e32cd27a0d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d29ead87806ceb2eb05c06e32cd27a0d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d29ead87806ceb2eb05c06e32cd27a0d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d29ead87806ceb2eb05c06e32cd27a0d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d29ead87806ceb2eb05c06e32cd27a0d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d29ead87806ceb2eb05c06e32cd27a0d,
        type_description_1,
        par_p
    );


    // Release cached frame.
    if ( frame_d29ead87806ceb2eb05c06e32cd27a0d == cache_frame_d29ead87806ceb2eb05c06e32cd27a0d )
    {
        Py_DECREF( frame_d29ead87806ceb2eb05c06e32cd27a0d );
    }
    cache_frame_d29ead87806ceb2eb05c06e32cd27a0d = NULL;

    assertFrameObject( frame_d29ead87806ceb2eb05c06e32cd27a0d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_28___libpd_unbind );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_28___libpd_unbind );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_29___libpd_openfile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_arg2 = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_ffe82fca45db6bdd4a31de8fd0802215;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ffe82fca45db6bdd4a31de8fd0802215 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ffe82fca45db6bdd4a31de8fd0802215, codeobj_ffe82fca45db6bdd4a31de8fd0802215, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_ffe82fca45db6bdd4a31de8fd0802215 = cache_frame_ffe82fca45db6bdd4a31de8fd0802215;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ffe82fca45db6bdd4a31de8fd0802215 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ffe82fca45db6bdd4a31de8fd0802215 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 188;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        CHECK_OBJECT( par_arg2 );
        tmp_args_element_name_2 = par_arg2;
        frame_ffe82fca45db6bdd4a31de8fd0802215->m_frame.f_lineno = 188;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___libpd_openfile, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 188;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ffe82fca45db6bdd4a31de8fd0802215 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ffe82fca45db6bdd4a31de8fd0802215 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ffe82fca45db6bdd4a31de8fd0802215 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ffe82fca45db6bdd4a31de8fd0802215, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ffe82fca45db6bdd4a31de8fd0802215->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ffe82fca45db6bdd4a31de8fd0802215, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ffe82fca45db6bdd4a31de8fd0802215,
        type_description_1,
        par_arg1,
        par_arg2
    );


    // Release cached frame.
    if ( frame_ffe82fca45db6bdd4a31de8fd0802215 == cache_frame_ffe82fca45db6bdd4a31de8fd0802215 )
    {
        Py_DECREF( frame_ffe82fca45db6bdd4a31de8fd0802215 );
    }
    cache_frame_ffe82fca45db6bdd4a31de8fd0802215 = NULL;

    assertFrameObject( frame_ffe82fca45db6bdd4a31de8fd0802215 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_29___libpd_openfile );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_29___libpd_openfile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_30___libpd_closefile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_081627b32714c4dc4f79f1da7855cefe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_081627b32714c4dc4f79f1da7855cefe = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_081627b32714c4dc4f79f1da7855cefe, codeobj_081627b32714c4dc4f79f1da7855cefe, module_pylibpd, sizeof(void *) );
    frame_081627b32714c4dc4f79f1da7855cefe = cache_frame_081627b32714c4dc4f79f1da7855cefe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_081627b32714c4dc4f79f1da7855cefe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_081627b32714c4dc4f79f1da7855cefe ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 192;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        frame_081627b32714c4dc4f79f1da7855cefe->m_frame.f_lineno = 192;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_closefile, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 192;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_081627b32714c4dc4f79f1da7855cefe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_081627b32714c4dc4f79f1da7855cefe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_081627b32714c4dc4f79f1da7855cefe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_081627b32714c4dc4f79f1da7855cefe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_081627b32714c4dc4f79f1da7855cefe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_081627b32714c4dc4f79f1da7855cefe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_081627b32714c4dc4f79f1da7855cefe,
        type_description_1,
        par_arg1
    );


    // Release cached frame.
    if ( frame_081627b32714c4dc4f79f1da7855cefe == cache_frame_081627b32714c4dc4f79f1da7855cefe )
    {
        Py_DECREF( frame_081627b32714c4dc4f79f1da7855cefe );
    }
    cache_frame_081627b32714c4dc4f79f1da7855cefe = NULL;

    assertFrameObject( frame_081627b32714c4dc4f79f1da7855cefe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_30___libpd_closefile );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_30___libpd_closefile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_31___libpd_getdollarzero( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_7d03f83e6dcc89c3664b73e19d33999f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7d03f83e6dcc89c3664b73e19d33999f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7d03f83e6dcc89c3664b73e19d33999f, codeobj_7d03f83e6dcc89c3664b73e19d33999f, module_pylibpd, sizeof(void *) );
    frame_7d03f83e6dcc89c3664b73e19d33999f = cache_frame_7d03f83e6dcc89c3664b73e19d33999f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7d03f83e6dcc89c3664b73e19d33999f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7d03f83e6dcc89c3664b73e19d33999f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 196;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_arg1 );
        tmp_args_element_name_1 = par_arg1;
        frame_7d03f83e6dcc89c3664b73e19d33999f->m_frame.f_lineno = 196;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___libpd_getdollarzero, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 196;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d03f83e6dcc89c3664b73e19d33999f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d03f83e6dcc89c3664b73e19d33999f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d03f83e6dcc89c3664b73e19d33999f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7d03f83e6dcc89c3664b73e19d33999f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7d03f83e6dcc89c3664b73e19d33999f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7d03f83e6dcc89c3664b73e19d33999f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7d03f83e6dcc89c3664b73e19d33999f,
        type_description_1,
        par_arg1
    );


    // Release cached frame.
    if ( frame_7d03f83e6dcc89c3664b73e19d33999f == cache_frame_7d03f83e6dcc89c3664b73e19d33999f )
    {
        Py_DECREF( frame_7d03f83e6dcc89c3664b73e19d33999f );
    }
    cache_frame_7d03f83e6dcc89c3664b73e19d33999f = NULL;

    assertFrameObject( frame_7d03f83e6dcc89c3664b73e19d33999f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_31___libpd_getdollarzero );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_31___libpd_getdollarzero );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_32_libpd_noteon( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ch = python_pars[ 0 ];
    PyObject *par_n = python_pars[ 1 ];
    PyObject *par_v = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_6a6079783c9362b20448bac27358928a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6a6079783c9362b20448bac27358928a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a6079783c9362b20448bac27358928a, codeobj_6a6079783c9362b20448bac27358928a, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6a6079783c9362b20448bac27358928a = cache_frame_6a6079783c9362b20448bac27358928a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a6079783c9362b20448bac27358928a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a6079783c9362b20448bac27358928a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 200;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ch );
        tmp_args_element_name_1 = par_ch;
        CHECK_OBJECT( par_n );
        tmp_args_element_name_2 = par_n;
        CHECK_OBJECT( par_v );
        tmp_args_element_name_3 = par_v;
        frame_6a6079783c9362b20448bac27358928a->m_frame.f_lineno = 200;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_noteon, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 200;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a6079783c9362b20448bac27358928a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a6079783c9362b20448bac27358928a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a6079783c9362b20448bac27358928a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a6079783c9362b20448bac27358928a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a6079783c9362b20448bac27358928a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a6079783c9362b20448bac27358928a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a6079783c9362b20448bac27358928a,
        type_description_1,
        par_ch,
        par_n,
        par_v
    );


    // Release cached frame.
    if ( frame_6a6079783c9362b20448bac27358928a == cache_frame_6a6079783c9362b20448bac27358928a )
    {
        Py_DECREF( frame_6a6079783c9362b20448bac27358928a );
    }
    cache_frame_6a6079783c9362b20448bac27358928a = NULL;

    assertFrameObject( frame_6a6079783c9362b20448bac27358928a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_32_libpd_noteon );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_32_libpd_noteon );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_33_libpd_controlchange( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ch = python_pars[ 0 ];
    PyObject *par_n = python_pars[ 1 ];
    PyObject *par_v = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_33b8c183561d8ad30ad8d6cc9e4f63ff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_33b8c183561d8ad30ad8d6cc9e4f63ff = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_33b8c183561d8ad30ad8d6cc9e4f63ff, codeobj_33b8c183561d8ad30ad8d6cc9e4f63ff, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_33b8c183561d8ad30ad8d6cc9e4f63ff = cache_frame_33b8c183561d8ad30ad8d6cc9e4f63ff;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_33b8c183561d8ad30ad8d6cc9e4f63ff );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_33b8c183561d8ad30ad8d6cc9e4f63ff ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 204;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ch );
        tmp_args_element_name_1 = par_ch;
        CHECK_OBJECT( par_n );
        tmp_args_element_name_2 = par_n;
        CHECK_OBJECT( par_v );
        tmp_args_element_name_3 = par_v;
        frame_33b8c183561d8ad30ad8d6cc9e4f63ff->m_frame.f_lineno = 204;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_controlchange, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 204;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33b8c183561d8ad30ad8d6cc9e4f63ff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_33b8c183561d8ad30ad8d6cc9e4f63ff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33b8c183561d8ad30ad8d6cc9e4f63ff );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_33b8c183561d8ad30ad8d6cc9e4f63ff, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_33b8c183561d8ad30ad8d6cc9e4f63ff->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_33b8c183561d8ad30ad8d6cc9e4f63ff, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_33b8c183561d8ad30ad8d6cc9e4f63ff,
        type_description_1,
        par_ch,
        par_n,
        par_v
    );


    // Release cached frame.
    if ( frame_33b8c183561d8ad30ad8d6cc9e4f63ff == cache_frame_33b8c183561d8ad30ad8d6cc9e4f63ff )
    {
        Py_DECREF( frame_33b8c183561d8ad30ad8d6cc9e4f63ff );
    }
    cache_frame_33b8c183561d8ad30ad8d6cc9e4f63ff = NULL;

    assertFrameObject( frame_33b8c183561d8ad30ad8d6cc9e4f63ff );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_33_libpd_controlchange );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_33_libpd_controlchange );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_34_libpd_programchange( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ch = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_02a37784f2b45c3c669122f5502c92b7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_02a37784f2b45c3c669122f5502c92b7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_02a37784f2b45c3c669122f5502c92b7, codeobj_02a37784f2b45c3c669122f5502c92b7, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_02a37784f2b45c3c669122f5502c92b7 = cache_frame_02a37784f2b45c3c669122f5502c92b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_02a37784f2b45c3c669122f5502c92b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_02a37784f2b45c3c669122f5502c92b7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 208;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ch );
        tmp_args_element_name_1 = par_ch;
        CHECK_OBJECT( par_p );
        tmp_args_element_name_2 = par_p;
        frame_02a37784f2b45c3c669122f5502c92b7->m_frame.f_lineno = 208;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_programchange, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 208;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02a37784f2b45c3c669122f5502c92b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_02a37784f2b45c3c669122f5502c92b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02a37784f2b45c3c669122f5502c92b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_02a37784f2b45c3c669122f5502c92b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_02a37784f2b45c3c669122f5502c92b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_02a37784f2b45c3c669122f5502c92b7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_02a37784f2b45c3c669122f5502c92b7,
        type_description_1,
        par_ch,
        par_p
    );


    // Release cached frame.
    if ( frame_02a37784f2b45c3c669122f5502c92b7 == cache_frame_02a37784f2b45c3c669122f5502c92b7 )
    {
        Py_DECREF( frame_02a37784f2b45c3c669122f5502c92b7 );
    }
    cache_frame_02a37784f2b45c3c669122f5502c92b7 = NULL;

    assertFrameObject( frame_02a37784f2b45c3c669122f5502c92b7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_34_libpd_programchange );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_34_libpd_programchange );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_35_libpd_pitchbend( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ch = python_pars[ 0 ];
    PyObject *par_b = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_9b41b3f0701460461aebf73f01228470;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9b41b3f0701460461aebf73f01228470 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9b41b3f0701460461aebf73f01228470, codeobj_9b41b3f0701460461aebf73f01228470, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_9b41b3f0701460461aebf73f01228470 = cache_frame_9b41b3f0701460461aebf73f01228470;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9b41b3f0701460461aebf73f01228470 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9b41b3f0701460461aebf73f01228470 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 212;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ch );
        tmp_args_element_name_1 = par_ch;
        CHECK_OBJECT( par_b );
        tmp_args_element_name_2 = par_b;
        frame_9b41b3f0701460461aebf73f01228470->m_frame.f_lineno = 212;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_pitchbend, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 212;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b41b3f0701460461aebf73f01228470 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b41b3f0701460461aebf73f01228470 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b41b3f0701460461aebf73f01228470 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9b41b3f0701460461aebf73f01228470, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9b41b3f0701460461aebf73f01228470->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9b41b3f0701460461aebf73f01228470, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b41b3f0701460461aebf73f01228470,
        type_description_1,
        par_ch,
        par_b
    );


    // Release cached frame.
    if ( frame_9b41b3f0701460461aebf73f01228470 == cache_frame_9b41b3f0701460461aebf73f01228470 )
    {
        Py_DECREF( frame_9b41b3f0701460461aebf73f01228470 );
    }
    cache_frame_9b41b3f0701460461aebf73f01228470 = NULL;

    assertFrameObject( frame_9b41b3f0701460461aebf73f01228470 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_35_libpd_pitchbend );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_35_libpd_pitchbend );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_36_libpd_aftertouch( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ch = python_pars[ 0 ];
    PyObject *par_v = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0b068d00f991b4aa4c21b69db841c716;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0b068d00f991b4aa4c21b69db841c716 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0b068d00f991b4aa4c21b69db841c716, codeobj_0b068d00f991b4aa4c21b69db841c716, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_0b068d00f991b4aa4c21b69db841c716 = cache_frame_0b068d00f991b4aa4c21b69db841c716;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0b068d00f991b4aa4c21b69db841c716 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0b068d00f991b4aa4c21b69db841c716 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 216;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ch );
        tmp_args_element_name_1 = par_ch;
        CHECK_OBJECT( par_v );
        tmp_args_element_name_2 = par_v;
        frame_0b068d00f991b4aa4c21b69db841c716->m_frame.f_lineno = 216;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_aftertouch, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 216;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b068d00f991b4aa4c21b69db841c716 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b068d00f991b4aa4c21b69db841c716 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b068d00f991b4aa4c21b69db841c716 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0b068d00f991b4aa4c21b69db841c716, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0b068d00f991b4aa4c21b69db841c716->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0b068d00f991b4aa4c21b69db841c716, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0b068d00f991b4aa4c21b69db841c716,
        type_description_1,
        par_ch,
        par_v
    );


    // Release cached frame.
    if ( frame_0b068d00f991b4aa4c21b69db841c716 == cache_frame_0b068d00f991b4aa4c21b69db841c716 )
    {
        Py_DECREF( frame_0b068d00f991b4aa4c21b69db841c716 );
    }
    cache_frame_0b068d00f991b4aa4c21b69db841c716 = NULL;

    assertFrameObject( frame_0b068d00f991b4aa4c21b69db841c716 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_36_libpd_aftertouch );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_36_libpd_aftertouch );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_37_libpd_polyaftertouch( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ch = python_pars[ 0 ];
    PyObject *par_n = python_pars[ 1 ];
    PyObject *par_v = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_76349622e9ca983d63f713959371dedd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_76349622e9ca983d63f713959371dedd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_76349622e9ca983d63f713959371dedd, codeobj_76349622e9ca983d63f713959371dedd, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_76349622e9ca983d63f713959371dedd = cache_frame_76349622e9ca983d63f713959371dedd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_76349622e9ca983d63f713959371dedd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_76349622e9ca983d63f713959371dedd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 220;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ch );
        tmp_args_element_name_1 = par_ch;
        CHECK_OBJECT( par_n );
        tmp_args_element_name_2 = par_n;
        CHECK_OBJECT( par_v );
        tmp_args_element_name_3 = par_v;
        frame_76349622e9ca983d63f713959371dedd->m_frame.f_lineno = 220;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_libpd_polyaftertouch, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 220;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76349622e9ca983d63f713959371dedd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_76349622e9ca983d63f713959371dedd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76349622e9ca983d63f713959371dedd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_76349622e9ca983d63f713959371dedd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_76349622e9ca983d63f713959371dedd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_76349622e9ca983d63f713959371dedd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_76349622e9ca983d63f713959371dedd,
        type_description_1,
        par_ch,
        par_n,
        par_v
    );


    // Release cached frame.
    if ( frame_76349622e9ca983d63f713959371dedd == cache_frame_76349622e9ca983d63f713959371dedd )
    {
        Py_DECREF( frame_76349622e9ca983d63f713959371dedd );
    }
    cache_frame_76349622e9ca983d63f713959371dedd = NULL;

    assertFrameObject( frame_76349622e9ca983d63f713959371dedd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_37_libpd_polyaftertouch );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ch );
    Py_DECREF( par_ch );
    par_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_v );
    Py_DECREF( par_v );
    par_v = NULL;

    CHECK_OBJECT( (PyObject *)par_n );
    Py_DECREF( par_n );
    par_n = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_37_libpd_polyaftertouch );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_38_libpd_midibyte( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_p = python_pars[ 0 ];
    PyObject *par_b = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_c416fef52457d1894040227253d35001;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c416fef52457d1894040227253d35001 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c416fef52457d1894040227253d35001, codeobj_c416fef52457d1894040227253d35001, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_c416fef52457d1894040227253d35001 = cache_frame_c416fef52457d1894040227253d35001;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c416fef52457d1894040227253d35001 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c416fef52457d1894040227253d35001 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 224;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_p );
        tmp_args_element_name_1 = par_p;
        CHECK_OBJECT( par_b );
        tmp_args_element_name_2 = par_b;
        frame_c416fef52457d1894040227253d35001->m_frame.f_lineno = 224;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_midibyte, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 224;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c416fef52457d1894040227253d35001 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c416fef52457d1894040227253d35001 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c416fef52457d1894040227253d35001 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c416fef52457d1894040227253d35001, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c416fef52457d1894040227253d35001->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c416fef52457d1894040227253d35001, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c416fef52457d1894040227253d35001,
        type_description_1,
        par_p,
        par_b
    );


    // Release cached frame.
    if ( frame_c416fef52457d1894040227253d35001 == cache_frame_c416fef52457d1894040227253d35001 )
    {
        Py_DECREF( frame_c416fef52457d1894040227253d35001 );
    }
    cache_frame_c416fef52457d1894040227253d35001 = NULL;

    assertFrameObject( frame_c416fef52457d1894040227253d35001 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_38_libpd_midibyte );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_38_libpd_midibyte );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_39_libpd_sysex( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_p = python_pars[ 0 ];
    PyObject *par_b = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b686d52c1e30b795289b80675fc8585e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b686d52c1e30b795289b80675fc8585e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b686d52c1e30b795289b80675fc8585e, codeobj_b686d52c1e30b795289b80675fc8585e, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_b686d52c1e30b795289b80675fc8585e = cache_frame_b686d52c1e30b795289b80675fc8585e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b686d52c1e30b795289b80675fc8585e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b686d52c1e30b795289b80675fc8585e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_p );
        tmp_args_element_name_1 = par_p;
        CHECK_OBJECT( par_b );
        tmp_args_element_name_2 = par_b;
        frame_b686d52c1e30b795289b80675fc8585e->m_frame.f_lineno = 228;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_sysex, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b686d52c1e30b795289b80675fc8585e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b686d52c1e30b795289b80675fc8585e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b686d52c1e30b795289b80675fc8585e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b686d52c1e30b795289b80675fc8585e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b686d52c1e30b795289b80675fc8585e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b686d52c1e30b795289b80675fc8585e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b686d52c1e30b795289b80675fc8585e,
        type_description_1,
        par_p,
        par_b
    );


    // Release cached frame.
    if ( frame_b686d52c1e30b795289b80675fc8585e == cache_frame_b686d52c1e30b795289b80675fc8585e )
    {
        Py_DECREF( frame_b686d52c1e30b795289b80675fc8585e );
    }
    cache_frame_b686d52c1e30b795289b80675fc8585e = NULL;

    assertFrameObject( frame_b686d52c1e30b795289b80675fc8585e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_39_libpd_sysex );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_39_libpd_sysex );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_40_libpd_sysrealtime( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_p = python_pars[ 0 ];
    PyObject *par_b = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_bfe583942d63a0207ea73d35a4df9663;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bfe583942d63a0207ea73d35a4df9663 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bfe583942d63a0207ea73d35a4df9663, codeobj_bfe583942d63a0207ea73d35a4df9663, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_bfe583942d63a0207ea73d35a4df9663 = cache_frame_bfe583942d63a0207ea73d35a4df9663;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bfe583942d63a0207ea73d35a4df9663 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bfe583942d63a0207ea73d35a4df9663 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 232;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_p );
        tmp_args_element_name_1 = par_p;
        CHECK_OBJECT( par_b );
        tmp_args_element_name_2 = par_b;
        frame_bfe583942d63a0207ea73d35a4df9663->m_frame.f_lineno = 232;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_libpd_sysrealtime, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 232;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bfe583942d63a0207ea73d35a4df9663 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bfe583942d63a0207ea73d35a4df9663 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bfe583942d63a0207ea73d35a4df9663 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bfe583942d63a0207ea73d35a4df9663, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bfe583942d63a0207ea73d35a4df9663->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bfe583942d63a0207ea73d35a4df9663, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bfe583942d63a0207ea73d35a4df9663,
        type_description_1,
        par_p,
        par_b
    );


    // Release cached frame.
    if ( frame_bfe583942d63a0207ea73d35a4df9663 == cache_frame_bfe583942d63a0207ea73d35a4df9663 )
    {
        Py_DECREF( frame_bfe583942d63a0207ea73d35a4df9663 );
    }
    cache_frame_bfe583942d63a0207ea73d35a4df9663 = NULL;

    assertFrameObject( frame_bfe583942d63a0207ea73d35a4df9663 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_40_libpd_sysrealtime );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_p );
    Py_DECREF( par_p );
    par_p = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_40_libpd_sysrealtime );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_41_libpd_set_print_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_cc17d197781e6408060b20f3d83b6a4d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cc17d197781e6408060b20f3d83b6a4d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cc17d197781e6408060b20f3d83b6a4d, codeobj_cc17d197781e6408060b20f3d83b6a4d, module_pylibpd, sizeof(void *) );
    frame_cc17d197781e6408060b20f3d83b6a4d = cache_frame_cc17d197781e6408060b20f3d83b6a4d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cc17d197781e6408060b20f3d83b6a4d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cc17d197781e6408060b20f3d83b6a4d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_cc17d197781e6408060b20f3d83b6a4d->m_frame.f_lineno = 236;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_print_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc17d197781e6408060b20f3d83b6a4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc17d197781e6408060b20f3d83b6a4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc17d197781e6408060b20f3d83b6a4d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cc17d197781e6408060b20f3d83b6a4d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cc17d197781e6408060b20f3d83b6a4d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cc17d197781e6408060b20f3d83b6a4d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cc17d197781e6408060b20f3d83b6a4d,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_cc17d197781e6408060b20f3d83b6a4d == cache_frame_cc17d197781e6408060b20f3d83b6a4d )
    {
        Py_DECREF( frame_cc17d197781e6408060b20f3d83b6a4d );
    }
    cache_frame_cc17d197781e6408060b20f3d83b6a4d = NULL;

    assertFrameObject( frame_cc17d197781e6408060b20f3d83b6a4d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_41_libpd_set_print_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_41_libpd_set_print_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_42_libpd_set_bang_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9f609cf12fb6702b215ca4e190df0150;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9f609cf12fb6702b215ca4e190df0150 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9f609cf12fb6702b215ca4e190df0150, codeobj_9f609cf12fb6702b215ca4e190df0150, module_pylibpd, sizeof(void *) );
    frame_9f609cf12fb6702b215ca4e190df0150 = cache_frame_9f609cf12fb6702b215ca4e190df0150;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9f609cf12fb6702b215ca4e190df0150 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9f609cf12fb6702b215ca4e190df0150 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 240;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_9f609cf12fb6702b215ca4e190df0150->m_frame.f_lineno = 240;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_bang_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 240;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f609cf12fb6702b215ca4e190df0150 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f609cf12fb6702b215ca4e190df0150 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9f609cf12fb6702b215ca4e190df0150 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9f609cf12fb6702b215ca4e190df0150, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9f609cf12fb6702b215ca4e190df0150->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9f609cf12fb6702b215ca4e190df0150, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9f609cf12fb6702b215ca4e190df0150,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_9f609cf12fb6702b215ca4e190df0150 == cache_frame_9f609cf12fb6702b215ca4e190df0150 )
    {
        Py_DECREF( frame_9f609cf12fb6702b215ca4e190df0150 );
    }
    cache_frame_9f609cf12fb6702b215ca4e190df0150 = NULL;

    assertFrameObject( frame_9f609cf12fb6702b215ca4e190df0150 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_42_libpd_set_bang_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_42_libpd_set_bang_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_43_libpd_set_float_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8386f14fa7ef7a1472148a612707d53d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8386f14fa7ef7a1472148a612707d53d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8386f14fa7ef7a1472148a612707d53d, codeobj_8386f14fa7ef7a1472148a612707d53d, module_pylibpd, sizeof(void *) );
    frame_8386f14fa7ef7a1472148a612707d53d = cache_frame_8386f14fa7ef7a1472148a612707d53d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8386f14fa7ef7a1472148a612707d53d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8386f14fa7ef7a1472148a612707d53d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 244;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_8386f14fa7ef7a1472148a612707d53d->m_frame.f_lineno = 244;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_float_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 244;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8386f14fa7ef7a1472148a612707d53d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8386f14fa7ef7a1472148a612707d53d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8386f14fa7ef7a1472148a612707d53d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8386f14fa7ef7a1472148a612707d53d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8386f14fa7ef7a1472148a612707d53d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8386f14fa7ef7a1472148a612707d53d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8386f14fa7ef7a1472148a612707d53d,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_8386f14fa7ef7a1472148a612707d53d == cache_frame_8386f14fa7ef7a1472148a612707d53d )
    {
        Py_DECREF( frame_8386f14fa7ef7a1472148a612707d53d );
    }
    cache_frame_8386f14fa7ef7a1472148a612707d53d = NULL;

    assertFrameObject( frame_8386f14fa7ef7a1472148a612707d53d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_43_libpd_set_float_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_43_libpd_set_float_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_44_libpd_set_symbol_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_939b16de371ad68ae9b6bfb148332ccf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_939b16de371ad68ae9b6bfb148332ccf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_939b16de371ad68ae9b6bfb148332ccf, codeobj_939b16de371ad68ae9b6bfb148332ccf, module_pylibpd, sizeof(void *) );
    frame_939b16de371ad68ae9b6bfb148332ccf = cache_frame_939b16de371ad68ae9b6bfb148332ccf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_939b16de371ad68ae9b6bfb148332ccf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_939b16de371ad68ae9b6bfb148332ccf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 248;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_939b16de371ad68ae9b6bfb148332ccf->m_frame.f_lineno = 248;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_symbol_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 248;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_939b16de371ad68ae9b6bfb148332ccf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_939b16de371ad68ae9b6bfb148332ccf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_939b16de371ad68ae9b6bfb148332ccf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_939b16de371ad68ae9b6bfb148332ccf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_939b16de371ad68ae9b6bfb148332ccf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_939b16de371ad68ae9b6bfb148332ccf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_939b16de371ad68ae9b6bfb148332ccf,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_939b16de371ad68ae9b6bfb148332ccf == cache_frame_939b16de371ad68ae9b6bfb148332ccf )
    {
        Py_DECREF( frame_939b16de371ad68ae9b6bfb148332ccf );
    }
    cache_frame_939b16de371ad68ae9b6bfb148332ccf = NULL;

    assertFrameObject( frame_939b16de371ad68ae9b6bfb148332ccf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_44_libpd_set_symbol_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_44_libpd_set_symbol_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_45_libpd_set_list_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_49832756a35e30a84f59c4adf04e130d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_49832756a35e30a84f59c4adf04e130d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_49832756a35e30a84f59c4adf04e130d, codeobj_49832756a35e30a84f59c4adf04e130d, module_pylibpd, sizeof(void *) );
    frame_49832756a35e30a84f59c4adf04e130d = cache_frame_49832756a35e30a84f59c4adf04e130d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_49832756a35e30a84f59c4adf04e130d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_49832756a35e30a84f59c4adf04e130d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 252;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_49832756a35e30a84f59c4adf04e130d->m_frame.f_lineno = 252;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_list_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 252;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49832756a35e30a84f59c4adf04e130d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_49832756a35e30a84f59c4adf04e130d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_49832756a35e30a84f59c4adf04e130d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_49832756a35e30a84f59c4adf04e130d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_49832756a35e30a84f59c4adf04e130d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_49832756a35e30a84f59c4adf04e130d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_49832756a35e30a84f59c4adf04e130d,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_49832756a35e30a84f59c4adf04e130d == cache_frame_49832756a35e30a84f59c4adf04e130d )
    {
        Py_DECREF( frame_49832756a35e30a84f59c4adf04e130d );
    }
    cache_frame_49832756a35e30a84f59c4adf04e130d = NULL;

    assertFrameObject( frame_49832756a35e30a84f59c4adf04e130d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_45_libpd_set_list_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_45_libpd_set_list_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_46_libpd_set_message_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d504bddcee8e4411a09cb993d761ed73;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d504bddcee8e4411a09cb993d761ed73 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d504bddcee8e4411a09cb993d761ed73, codeobj_d504bddcee8e4411a09cb993d761ed73, module_pylibpd, sizeof(void *) );
    frame_d504bddcee8e4411a09cb993d761ed73 = cache_frame_d504bddcee8e4411a09cb993d761ed73;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d504bddcee8e4411a09cb993d761ed73 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d504bddcee8e4411a09cb993d761ed73 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_d504bddcee8e4411a09cb993d761ed73->m_frame.f_lineno = 256;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_message_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 256;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d504bddcee8e4411a09cb993d761ed73 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d504bddcee8e4411a09cb993d761ed73 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d504bddcee8e4411a09cb993d761ed73 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d504bddcee8e4411a09cb993d761ed73, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d504bddcee8e4411a09cb993d761ed73->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d504bddcee8e4411a09cb993d761ed73, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d504bddcee8e4411a09cb993d761ed73,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_d504bddcee8e4411a09cb993d761ed73 == cache_frame_d504bddcee8e4411a09cb993d761ed73 )
    {
        Py_DECREF( frame_d504bddcee8e4411a09cb993d761ed73 );
    }
    cache_frame_d504bddcee8e4411a09cb993d761ed73 = NULL;

    assertFrameObject( frame_d504bddcee8e4411a09cb993d761ed73 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_46_libpd_set_message_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_46_libpd_set_message_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_47_libpd_set_noteon_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_91e54d526b6875d6ecdee23c34416080;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_91e54d526b6875d6ecdee23c34416080 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_91e54d526b6875d6ecdee23c34416080, codeobj_91e54d526b6875d6ecdee23c34416080, module_pylibpd, sizeof(void *) );
    frame_91e54d526b6875d6ecdee23c34416080 = cache_frame_91e54d526b6875d6ecdee23c34416080;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_91e54d526b6875d6ecdee23c34416080 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_91e54d526b6875d6ecdee23c34416080 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 260;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_91e54d526b6875d6ecdee23c34416080->m_frame.f_lineno = 260;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_noteon_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 260;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91e54d526b6875d6ecdee23c34416080 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_91e54d526b6875d6ecdee23c34416080 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_91e54d526b6875d6ecdee23c34416080 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_91e54d526b6875d6ecdee23c34416080, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_91e54d526b6875d6ecdee23c34416080->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_91e54d526b6875d6ecdee23c34416080, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_91e54d526b6875d6ecdee23c34416080,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_91e54d526b6875d6ecdee23c34416080 == cache_frame_91e54d526b6875d6ecdee23c34416080 )
    {
        Py_DECREF( frame_91e54d526b6875d6ecdee23c34416080 );
    }
    cache_frame_91e54d526b6875d6ecdee23c34416080 = NULL;

    assertFrameObject( frame_91e54d526b6875d6ecdee23c34416080 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_47_libpd_set_noteon_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_47_libpd_set_noteon_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_48_libpd_set_controlchange_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_93d9ddc9137f0c15be485242480929e6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_93d9ddc9137f0c15be485242480929e6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_93d9ddc9137f0c15be485242480929e6, codeobj_93d9ddc9137f0c15be485242480929e6, module_pylibpd, sizeof(void *) );
    frame_93d9ddc9137f0c15be485242480929e6 = cache_frame_93d9ddc9137f0c15be485242480929e6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_93d9ddc9137f0c15be485242480929e6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_93d9ddc9137f0c15be485242480929e6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_93d9ddc9137f0c15be485242480929e6->m_frame.f_lineno = 264;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_controlchange_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93d9ddc9137f0c15be485242480929e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_93d9ddc9137f0c15be485242480929e6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93d9ddc9137f0c15be485242480929e6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_93d9ddc9137f0c15be485242480929e6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_93d9ddc9137f0c15be485242480929e6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_93d9ddc9137f0c15be485242480929e6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_93d9ddc9137f0c15be485242480929e6,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_93d9ddc9137f0c15be485242480929e6 == cache_frame_93d9ddc9137f0c15be485242480929e6 )
    {
        Py_DECREF( frame_93d9ddc9137f0c15be485242480929e6 );
    }
    cache_frame_93d9ddc9137f0c15be485242480929e6 = NULL;

    assertFrameObject( frame_93d9ddc9137f0c15be485242480929e6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_48_libpd_set_controlchange_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_48_libpd_set_controlchange_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_49_libpd_set_programchange_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e98ce42509d553edec565b589a3402b8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e98ce42509d553edec565b589a3402b8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e98ce42509d553edec565b589a3402b8, codeobj_e98ce42509d553edec565b589a3402b8, module_pylibpd, sizeof(void *) );
    frame_e98ce42509d553edec565b589a3402b8 = cache_frame_e98ce42509d553edec565b589a3402b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e98ce42509d553edec565b589a3402b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e98ce42509d553edec565b589a3402b8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 268;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_e98ce42509d553edec565b589a3402b8->m_frame.f_lineno = 268;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_programchange_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 268;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e98ce42509d553edec565b589a3402b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e98ce42509d553edec565b589a3402b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e98ce42509d553edec565b589a3402b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e98ce42509d553edec565b589a3402b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e98ce42509d553edec565b589a3402b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e98ce42509d553edec565b589a3402b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e98ce42509d553edec565b589a3402b8,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_e98ce42509d553edec565b589a3402b8 == cache_frame_e98ce42509d553edec565b589a3402b8 )
    {
        Py_DECREF( frame_e98ce42509d553edec565b589a3402b8 );
    }
    cache_frame_e98ce42509d553edec565b589a3402b8 = NULL;

    assertFrameObject( frame_e98ce42509d553edec565b589a3402b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_49_libpd_set_programchange_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_49_libpd_set_programchange_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_50_libpd_set_pitchbend_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2aa96112640cdd6d7ba59bfefe4d05bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2aa96112640cdd6d7ba59bfefe4d05bb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2aa96112640cdd6d7ba59bfefe4d05bb, codeobj_2aa96112640cdd6d7ba59bfefe4d05bb, module_pylibpd, sizeof(void *) );
    frame_2aa96112640cdd6d7ba59bfefe4d05bb = cache_frame_2aa96112640cdd6d7ba59bfefe4d05bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2aa96112640cdd6d7ba59bfefe4d05bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2aa96112640cdd6d7ba59bfefe4d05bb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 272;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_2aa96112640cdd6d7ba59bfefe4d05bb->m_frame.f_lineno = 272;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_pitchbend_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2aa96112640cdd6d7ba59bfefe4d05bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2aa96112640cdd6d7ba59bfefe4d05bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2aa96112640cdd6d7ba59bfefe4d05bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2aa96112640cdd6d7ba59bfefe4d05bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2aa96112640cdd6d7ba59bfefe4d05bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2aa96112640cdd6d7ba59bfefe4d05bb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2aa96112640cdd6d7ba59bfefe4d05bb,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_2aa96112640cdd6d7ba59bfefe4d05bb == cache_frame_2aa96112640cdd6d7ba59bfefe4d05bb )
    {
        Py_DECREF( frame_2aa96112640cdd6d7ba59bfefe4d05bb );
    }
    cache_frame_2aa96112640cdd6d7ba59bfefe4d05bb = NULL;

    assertFrameObject( frame_2aa96112640cdd6d7ba59bfefe4d05bb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_50_libpd_set_pitchbend_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_50_libpd_set_pitchbend_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_51_libpd_set_aftertouch_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0e508c26b2577e99373cc510f79d1d17;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0e508c26b2577e99373cc510f79d1d17 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0e508c26b2577e99373cc510f79d1d17, codeobj_0e508c26b2577e99373cc510f79d1d17, module_pylibpd, sizeof(void *) );
    frame_0e508c26b2577e99373cc510f79d1d17 = cache_frame_0e508c26b2577e99373cc510f79d1d17;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0e508c26b2577e99373cc510f79d1d17 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0e508c26b2577e99373cc510f79d1d17 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 276;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_0e508c26b2577e99373cc510f79d1d17->m_frame.f_lineno = 276;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_aftertouch_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 276;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0e508c26b2577e99373cc510f79d1d17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0e508c26b2577e99373cc510f79d1d17 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0e508c26b2577e99373cc510f79d1d17 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0e508c26b2577e99373cc510f79d1d17, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0e508c26b2577e99373cc510f79d1d17->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0e508c26b2577e99373cc510f79d1d17, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0e508c26b2577e99373cc510f79d1d17,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_0e508c26b2577e99373cc510f79d1d17 == cache_frame_0e508c26b2577e99373cc510f79d1d17 )
    {
        Py_DECREF( frame_0e508c26b2577e99373cc510f79d1d17 );
    }
    cache_frame_0e508c26b2577e99373cc510f79d1d17 = NULL;

    assertFrameObject( frame_0e508c26b2577e99373cc510f79d1d17 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_51_libpd_set_aftertouch_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_51_libpd_set_aftertouch_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_52_libpd_set_polyaftertouch_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a940df66d49765e4a3a3cce2004dbdf3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a940df66d49765e4a3a3cce2004dbdf3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a940df66d49765e4a3a3cce2004dbdf3, codeobj_a940df66d49765e4a3a3cce2004dbdf3, module_pylibpd, sizeof(void *) );
    frame_a940df66d49765e4a3a3cce2004dbdf3 = cache_frame_a940df66d49765e4a3a3cce2004dbdf3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a940df66d49765e4a3a3cce2004dbdf3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a940df66d49765e4a3a3cce2004dbdf3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_a940df66d49765e4a3a3cce2004dbdf3->m_frame.f_lineno = 280;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_polyaftertouch_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a940df66d49765e4a3a3cce2004dbdf3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a940df66d49765e4a3a3cce2004dbdf3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a940df66d49765e4a3a3cce2004dbdf3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a940df66d49765e4a3a3cce2004dbdf3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a940df66d49765e4a3a3cce2004dbdf3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a940df66d49765e4a3a3cce2004dbdf3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a940df66d49765e4a3a3cce2004dbdf3,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_a940df66d49765e4a3a3cce2004dbdf3 == cache_frame_a940df66d49765e4a3a3cce2004dbdf3 )
    {
        Py_DECREF( frame_a940df66d49765e4a3a3cce2004dbdf3 );
    }
    cache_frame_a940df66d49765e4a3a3cce2004dbdf3 = NULL;

    assertFrameObject( frame_a940df66d49765e4a3a3cce2004dbdf3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_52_libpd_set_polyaftertouch_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_52_libpd_set_polyaftertouch_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_53_libpd_set_midibyte_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_callback = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_353278295782574f178182e484b36135;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_353278295782574f178182e484b36135 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_353278295782574f178182e484b36135, codeobj_353278295782574f178182e484b36135, module_pylibpd, sizeof(void *) );
    frame_353278295782574f178182e484b36135 = cache_frame_353278295782574f178182e484b36135;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_353278295782574f178182e484b36135 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_353278295782574f178182e484b36135 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 284;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_353278295782574f178182e484b36135->m_frame.f_lineno = 284;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_libpd_set_midibyte_callback, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 284;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_353278295782574f178182e484b36135 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_353278295782574f178182e484b36135 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_353278295782574f178182e484b36135 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_353278295782574f178182e484b36135, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_353278295782574f178182e484b36135->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_353278295782574f178182e484b36135, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_353278295782574f178182e484b36135,
        type_description_1,
        par_callback
    );


    // Release cached frame.
    if ( frame_353278295782574f178182e484b36135 == cache_frame_353278295782574f178182e484b36135 )
    {
        Py_DECREF( frame_353278295782574f178182e484b36135 );
    }
    cache_frame_353278295782574f178182e484b36135 = NULL;

    assertFrameObject( frame_353278295782574f178182e484b36135 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_53_libpd_set_midibyte_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_53_libpd_set_midibyte_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_54___process_args( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *var_arg = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_38c0d26bc756e19052564548acf50807;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_38c0d26bc756e19052564548acf50807 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_38c0d26bc756e19052564548acf50807, codeobj_38c0d26bc756e19052564548acf50807, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_38c0d26bc756e19052564548acf50807 = cache_frame_38c0d26bc756e19052564548acf50807;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_38c0d26bc756e19052564548acf50807 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_38c0d26bc756e19052564548acf50807 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_start_message );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_start_message );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_start_message" );
            exception_tb = NULL;

            exception_lineno = 290;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_args );
        tmp_len_arg_1 = par_args;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 290;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_38c0d26bc756e19052564548acf50807->m_frame.f_lineno = 290;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 290;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 290;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = const_int_neg_2;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_args );
        tmp_iter_arg_1 = par_args;
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 291;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                exception_lineno = 291;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_arg;
            var_arg = tmp_assign_source_3;
            Py_INCREF( var_arg );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( var_arg );
        tmp_isinstance_inst_1 = var_arg;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 292;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_add_symbol );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_add_symbol );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_add_symbol" );
                exception_tb = NULL;

                exception_lineno = 293;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            CHECK_OBJECT( var_arg );
            tmp_args_element_name_2 = var_arg;
            frame_38c0d26bc756e19052564548acf50807->m_frame.f_lineno = 293;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 293;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            int tmp_or_left_truth_1;
            nuitka_bool tmp_or_left_value_1;
            nuitka_bool tmp_or_right_value_1;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_isinstance_inst_3;
            PyObject *tmp_isinstance_cls_3;
            CHECK_OBJECT( var_arg );
            tmp_isinstance_inst_2 = var_arg;
            tmp_isinstance_cls_2 = (PyObject *)&PyInt_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 295;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_or_left_truth_1 == 1 )
            {
                goto or_left_1;
            }
            else
            {
                goto or_right_1;
            }
            or_right_1:;
            CHECK_OBJECT( var_arg );
            tmp_isinstance_inst_3 = var_arg;
            tmp_isinstance_cls_3 = (PyObject *)&PyFloat_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 295;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            tmp_or_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_3 = tmp_or_right_value_1;
            goto or_end_1;
            or_left_1:;
            tmp_condition_result_3 = tmp_or_left_value_1;
            or_end_1:;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_3;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_add_float );

                if (unlikely( tmp_mvar_value_3 == NULL ))
                {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_add_float );
                }

                if ( tmp_mvar_value_3 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_add_float" );
                    exception_tb = NULL;

                    exception_lineno = 296;
                    type_description_1 = "oo";
                    goto try_except_handler_2;
                }

                tmp_called_name_3 = tmp_mvar_value_3;
                CHECK_OBJECT( var_arg );
                tmp_args_element_name_3 = var_arg;
                frame_38c0d26bc756e19052564548acf50807->m_frame.f_lineno = 296;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
                }

                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 296;
                    type_description_1 = "oo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_3 );
            }
            goto branch_end_3;
            branch_no_3:;
            tmp_return_value = const_int_neg_1;
            Py_INCREF( tmp_return_value );
            goto try_return_handler_2;
            branch_end_3:;
        }
        branch_end_2:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 291;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_38c0d26bc756e19052564548acf50807 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_38c0d26bc756e19052564548acf50807 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_38c0d26bc756e19052564548acf50807 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_38c0d26bc756e19052564548acf50807, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_38c0d26bc756e19052564548acf50807->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_38c0d26bc756e19052564548acf50807, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_38c0d26bc756e19052564548acf50807,
        type_description_1,
        par_args,
        var_arg
    );


    // Release cached frame.
    if ( frame_38c0d26bc756e19052564548acf50807 == cache_frame_38c0d26bc756e19052564548acf50807 )
    {
        Py_DECREF( frame_38c0d26bc756e19052564548acf50807 );
    }
    cache_frame_38c0d26bc756e19052564548acf50807 = NULL;

    assertFrameObject( frame_38c0d26bc756e19052564548acf50807 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_54___process_args );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    Py_XDECREF( var_arg );
    var_arg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_54___process_args );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_55_libpd_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dest = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_89383b11fa2394246d9479e8a9ffa0ce;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_89383b11fa2394246d9479e8a9ffa0ce = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_89383b11fa2394246d9479e8a9ffa0ce, codeobj_89383b11fa2394246d9479e8a9ffa0ce, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_89383b11fa2394246d9479e8a9ffa0ce = cache_frame_89383b11fa2394246d9479e8a9ffa0ce;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_89383b11fa2394246d9479e8a9ffa0ce );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_89383b11fa2394246d9479e8a9ffa0ce ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___process_args );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___process_args );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__process_args" );
            exception_tb = NULL;

            exception_lineno = 302;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_args );
        tmp_args_element_name_1 = par_args;
        frame_89383b11fa2394246d9479e8a9ffa0ce->m_frame.f_lineno = 302;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_or_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 302;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
        if ( tmp_or_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_or_left_value_1 );

            exception_lineno = 302;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        Py_DECREF( tmp_or_left_value_1 );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_finish_list );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_finish_list );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_finish_list" );
            exception_tb = NULL;

            exception_lineno = 302;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_dest );
        tmp_args_element_name_2 = par_dest;
        frame_89383b11fa2394246d9479e8a9ffa0ce->m_frame.f_lineno = 302;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_or_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 302;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_return_value = tmp_or_left_value_1;
        or_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_89383b11fa2394246d9479e8a9ffa0ce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_89383b11fa2394246d9479e8a9ffa0ce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_89383b11fa2394246d9479e8a9ffa0ce );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_89383b11fa2394246d9479e8a9ffa0ce, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_89383b11fa2394246d9479e8a9ffa0ce->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_89383b11fa2394246d9479e8a9ffa0ce, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_89383b11fa2394246d9479e8a9ffa0ce,
        type_description_1,
        par_dest,
        par_args
    );


    // Release cached frame.
    if ( frame_89383b11fa2394246d9479e8a9ffa0ce == cache_frame_89383b11fa2394246d9479e8a9ffa0ce )
    {
        Py_DECREF( frame_89383b11fa2394246d9479e8a9ffa0ce );
    }
    cache_frame_89383b11fa2394246d9479e8a9ffa0ce = NULL;

    assertFrameObject( frame_89383b11fa2394246d9479e8a9ffa0ce );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_55_libpd_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_55_libpd_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_56_libpd_message( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dest = python_pars[ 0 ];
    PyObject *par_sym = python_pars[ 1 ];
    PyObject *par_args = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_d9975fdcb0550d907412bc2e53163472;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d9975fdcb0550d907412bc2e53163472 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d9975fdcb0550d907412bc2e53163472, codeobj_d9975fdcb0550d907412bc2e53163472, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d9975fdcb0550d907412bc2e53163472 = cache_frame_d9975fdcb0550d907412bc2e53163472;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d9975fdcb0550d907412bc2e53163472 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d9975fdcb0550d907412bc2e53163472 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___process_args );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___process_args );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__process_args" );
            exception_tb = NULL;

            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_args );
        tmp_args_element_name_1 = par_args;
        frame_d9975fdcb0550d907412bc2e53163472->m_frame.f_lineno = 305;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_or_left_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
        if ( tmp_or_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_or_left_value_1 );

            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        Py_DECREF( tmp_or_left_value_1 );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_finish_message );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_finish_message );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_finish_message" );
            exception_tb = NULL;

            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_dest );
        tmp_args_element_name_2 = par_dest;
        CHECK_OBJECT( par_sym );
        tmp_args_element_name_3 = par_sym;
        frame_d9975fdcb0550d907412bc2e53163472->m_frame.f_lineno = 305;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_or_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 305;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_return_value = tmp_or_left_value_1;
        or_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9975fdcb0550d907412bc2e53163472 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9975fdcb0550d907412bc2e53163472 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9975fdcb0550d907412bc2e53163472 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d9975fdcb0550d907412bc2e53163472, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d9975fdcb0550d907412bc2e53163472->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d9975fdcb0550d907412bc2e53163472, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d9975fdcb0550d907412bc2e53163472,
        type_description_1,
        par_dest,
        par_sym,
        par_args
    );


    // Release cached frame.
    if ( frame_d9975fdcb0550d907412bc2e53163472 == cache_frame_d9975fdcb0550d907412bc2e53163472 )
    {
        Py_DECREF( frame_d9975fdcb0550d907412bc2e53163472 );
    }
    cache_frame_d9975fdcb0550d907412bc2e53163472 = NULL;

    assertFrameObject( frame_d9975fdcb0550d907412bc2e53163472 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_56_libpd_message );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dest );
    Py_DECREF( par_dest );
    par_dest = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_56_libpd_message );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_57_libpd_open_patch( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_patch = python_pars[ 0 ];
    PyObject *par_dir = python_pars[ 1 ];
    PyObject *var_dz = NULL;
    PyObject *var_ptr = NULL;
    struct Nuitka_FrameObject *frame_134c2eef919a2e020ca576e89a1ef1b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_134c2eef919a2e020ca576e89a1ef1b0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_134c2eef919a2e020ca576e89a1ef1b0, codeobj_134c2eef919a2e020ca576e89a1ef1b0, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_134c2eef919a2e020ca576e89a1ef1b0 = cache_frame_134c2eef919a2e020ca576e89a1ef1b0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_134c2eef919a2e020ca576e89a1ef1b0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_134c2eef919a2e020ca576e89a1ef1b0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_openfile );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_openfile );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_openfile" );
            exception_tb = NULL;

            exception_lineno = 310;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_patch );
        tmp_args_element_name_1 = par_patch;
        CHECK_OBJECT( par_dir );
        tmp_args_element_name_2 = par_dir;
        frame_134c2eef919a2e020ca576e89a1ef1b0->m_frame.f_lineno = 310;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 310;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_ptr == NULL );
        var_ptr = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_ptr );
        tmp_operand_name_1 = var_ptr;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            tmp_left_name_1 = const_str_digest_11dda6802c4e85aab42c2a57cc2ae2a9;
            CHECK_OBJECT( par_dir );
            tmp_tuple_element_1 = par_dir;
            tmp_right_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_patch );
            tmp_tuple_element_1 = par_patch;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 312;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_134c2eef919a2e020ca576e89a1ef1b0->m_frame.f_lineno = 312;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_IOError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 312;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_getdollarzero );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_getdollarzero );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_getdollarzero" );
            exception_tb = NULL;

            exception_lineno = 313;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_ptr );
        tmp_args_element_name_3 = var_ptr;
        frame_134c2eef919a2e020ca576e89a1ef1b0->m_frame.f_lineno = 313;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 313;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_dz == NULL );
        var_dz = tmp_assign_source_2;
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_ass_subscript_1;
        CHECK_OBJECT( var_ptr );
        tmp_ass_subvalue_1 = var_ptr;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_patches );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_patches );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_patches" );
            exception_tb = NULL;

            exception_lineno = 314;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_ass_subscribed_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_dz );
        tmp_ass_subscript_1 = var_dz;
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 314;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_134c2eef919a2e020ca576e89a1ef1b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_134c2eef919a2e020ca576e89a1ef1b0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_134c2eef919a2e020ca576e89a1ef1b0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_134c2eef919a2e020ca576e89a1ef1b0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_134c2eef919a2e020ca576e89a1ef1b0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_134c2eef919a2e020ca576e89a1ef1b0,
        type_description_1,
        par_patch,
        par_dir,
        var_dz,
        var_ptr
    );


    // Release cached frame.
    if ( frame_134c2eef919a2e020ca576e89a1ef1b0 == cache_frame_134c2eef919a2e020ca576e89a1ef1b0 )
    {
        Py_DECREF( frame_134c2eef919a2e020ca576e89a1ef1b0 );
    }
    cache_frame_134c2eef919a2e020ca576e89a1ef1b0 = NULL;

    assertFrameObject( frame_134c2eef919a2e020ca576e89a1ef1b0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_dz );
    tmp_return_value = var_dz;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_57_libpd_open_patch );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_dz );
    Py_DECREF( var_dz );
    var_dz = NULL;

    CHECK_OBJECT( (PyObject *)var_ptr );
    Py_DECREF( var_ptr );
    var_ptr = NULL;

    CHECK_OBJECT( (PyObject *)par_dir );
    Py_DECREF( par_dir );
    par_dir = NULL;

    CHECK_OBJECT( (PyObject *)par_patch );
    Py_DECREF( par_patch );
    par_patch = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_dz );
    var_dz = NULL;

    Py_XDECREF( var_ptr );
    var_ptr = NULL;

    CHECK_OBJECT( (PyObject *)par_dir );
    Py_DECREF( par_dir );
    par_dir = NULL;

    CHECK_OBJECT( (PyObject *)par_patch );
    Py_DECREF( par_patch );
    par_patch = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_57_libpd_open_patch );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_58_libpd_close_patch( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_dz = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1cacc913ed2a0459d4ecf08b45761e89;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_1cacc913ed2a0459d4ecf08b45761e89 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1cacc913ed2a0459d4ecf08b45761e89, codeobj_1cacc913ed2a0459d4ecf08b45761e89, module_pylibpd, sizeof(void *) );
    frame_1cacc913ed2a0459d4ecf08b45761e89 = cache_frame_1cacc913ed2a0459d4ecf08b45761e89;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1cacc913ed2a0459d4ecf08b45761e89 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1cacc913ed2a0459d4ecf08b45761e89 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_closefile );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_closefile );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_closefile" );
            exception_tb = NULL;

            exception_lineno = 318;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_patches );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_patches );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_patches" );
            exception_tb = NULL;

            exception_lineno = 318;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_dz );
        tmp_subscript_name_1 = par_dz;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 318;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1cacc913ed2a0459d4ecf08b45761e89->m_frame.f_lineno = 318;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 318;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_delsubscr_target_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_delsubscr_subscript_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_patches );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_patches );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_patches" );
            exception_tb = NULL;

            exception_lineno = 319;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_delsubscr_target_1 = tmp_mvar_value_3;
        CHECK_OBJECT( par_dz );
        tmp_delsubscr_subscript_1 = par_dz;
        tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1cacc913ed2a0459d4ecf08b45761e89 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1cacc913ed2a0459d4ecf08b45761e89 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1cacc913ed2a0459d4ecf08b45761e89, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1cacc913ed2a0459d4ecf08b45761e89->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1cacc913ed2a0459d4ecf08b45761e89, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1cacc913ed2a0459d4ecf08b45761e89,
        type_description_1,
        par_dz
    );


    // Release cached frame.
    if ( frame_1cacc913ed2a0459d4ecf08b45761e89 == cache_frame_1cacc913ed2a0459d4ecf08b45761e89 )
    {
        Py_DECREF( frame_1cacc913ed2a0459d4ecf08b45761e89 );
    }
    cache_frame_1cacc913ed2a0459d4ecf08b45761e89 = NULL;

    assertFrameObject( frame_1cacc913ed2a0459d4ecf08b45761e89 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_58_libpd_close_patch );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dz );
    Py_DECREF( par_dz );
    par_dz = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dz );
    Py_DECREF( par_dz );
    par_dz = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_58_libpd_close_patch );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_59_libpd_subscribe( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_sym = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_dfc3cb6cc00162b1590553f83958ba26;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_dfc3cb6cc00162b1590553f83958ba26 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dfc3cb6cc00162b1590553f83958ba26, codeobj_dfc3cb6cc00162b1590553f83958ba26, module_pylibpd, sizeof(void *) );
    frame_dfc3cb6cc00162b1590553f83958ba26 = cache_frame_dfc3cb6cc00162b1590553f83958ba26;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dfc3cb6cc00162b1590553f83958ba26 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dfc3cb6cc00162b1590553f83958ba26 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_subscriptions" );
            exception_tb = NULL;

            exception_lineno = 324;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_sym );
        tmp_args_element_name_1 = par_sym;
        frame_dfc3cb6cc00162b1590553f83958ba26->m_frame.f_lineno = 324;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_has_key, call_args );
        }

        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 324;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 324;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_ass_subvalue_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_ass_subscribed_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_ass_subscript_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_bind );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_bind );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_bind" );
                exception_tb = NULL;

                exception_lineno = 325;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_sym );
            tmp_args_element_name_2 = par_sym;
            frame_dfc3cb6cc00162b1590553f83958ba26->m_frame.f_lineno = 325;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_ass_subvalue_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 325;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );
            }

            if ( tmp_mvar_value_3 == NULL )
            {
                Py_DECREF( tmp_ass_subvalue_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_subscriptions" );
                exception_tb = NULL;

                exception_lineno = 325;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_ass_subscribed_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_sym );
            tmp_ass_subscript_1 = par_sym;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
            Py_DECREF( tmp_ass_subvalue_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 325;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dfc3cb6cc00162b1590553f83958ba26 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dfc3cb6cc00162b1590553f83958ba26 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dfc3cb6cc00162b1590553f83958ba26, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dfc3cb6cc00162b1590553f83958ba26->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dfc3cb6cc00162b1590553f83958ba26, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dfc3cb6cc00162b1590553f83958ba26,
        type_description_1,
        par_sym
    );


    // Release cached frame.
    if ( frame_dfc3cb6cc00162b1590553f83958ba26 == cache_frame_dfc3cb6cc00162b1590553f83958ba26 )
    {
        Py_DECREF( frame_dfc3cb6cc00162b1590553f83958ba26 );
    }
    cache_frame_dfc3cb6cc00162b1590553f83958ba26 = NULL;

    assertFrameObject( frame_dfc3cb6cc00162b1590553f83958ba26 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_59_libpd_subscribe );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_59_libpd_subscribe );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_60_libpd_unsubscribe( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_sym = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4b73e8b34ff0b182963b09d6f49d1972;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_4b73e8b34ff0b182963b09d6f49d1972 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4b73e8b34ff0b182963b09d6f49d1972, codeobj_4b73e8b34ff0b182963b09d6f49d1972, module_pylibpd, sizeof(void *) );
    frame_4b73e8b34ff0b182963b09d6f49d1972 = cache_frame_4b73e8b34ff0b182963b09d6f49d1972;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4b73e8b34ff0b182963b09d6f49d1972 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4b73e8b34ff0b182963b09d6f49d1972 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_unbind );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_unbind );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_unbind" );
            exception_tb = NULL;

            exception_lineno = 328;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_subscriptions" );
            exception_tb = NULL;

            exception_lineno = 328;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_sym );
        tmp_subscript_name_1 = par_sym;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 328;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_4b73e8b34ff0b182963b09d6f49d1972->m_frame.f_lineno = 328;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 328;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_delsubscr_target_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_delsubscr_subscript_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_subscriptions" );
            exception_tb = NULL;

            exception_lineno = 329;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_delsubscr_target_1 = tmp_mvar_value_3;
        CHECK_OBJECT( par_sym );
        tmp_delsubscr_subscript_1 = par_sym;
        tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 329;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b73e8b34ff0b182963b09d6f49d1972 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b73e8b34ff0b182963b09d6f49d1972 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4b73e8b34ff0b182963b09d6f49d1972, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4b73e8b34ff0b182963b09d6f49d1972->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4b73e8b34ff0b182963b09d6f49d1972, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4b73e8b34ff0b182963b09d6f49d1972,
        type_description_1,
        par_sym
    );


    // Release cached frame.
    if ( frame_4b73e8b34ff0b182963b09d6f49d1972 == cache_frame_4b73e8b34ff0b182963b09d6f49d1972 )
    {
        Py_DECREF( frame_4b73e8b34ff0b182963b09d6f49d1972 );
    }
    cache_frame_4b73e8b34ff0b182963b09d6f49d1972 = NULL;

    assertFrameObject( frame_4b73e8b34ff0b182963b09d6f49d1972 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_60_libpd_unsubscribe );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_sym );
    Py_DECREF( par_sym );
    par_sym = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_60_libpd_unsubscribe );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_61_libpd_compute_audio( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_flag = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6c96b23369e54e55433f0730b526faa9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6c96b23369e54e55433f0730b526faa9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6c96b23369e54e55433f0730b526faa9, codeobj_6c96b23369e54e55433f0730b526faa9, module_pylibpd, sizeof(void *) );
    frame_6c96b23369e54e55433f0730b526faa9 = cache_frame_6c96b23369e54e55433f0730b526faa9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6c96b23369e54e55433f0730b526faa9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6c96b23369e54e55433f0730b526faa9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_message );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_libpd_message );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "libpd_message" );
            exception_tb = NULL;

            exception_lineno = 332;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_pd;
        tmp_args_element_name_2 = const_str_plain_dsp;
        CHECK_OBJECT( par_flag );
        tmp_args_element_name_3 = par_flag;
        frame_6c96b23369e54e55433f0730b526faa9->m_frame.f_lineno = 332;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 332;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c96b23369e54e55433f0730b526faa9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c96b23369e54e55433f0730b526faa9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6c96b23369e54e55433f0730b526faa9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6c96b23369e54e55433f0730b526faa9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6c96b23369e54e55433f0730b526faa9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6c96b23369e54e55433f0730b526faa9,
        type_description_1,
        par_flag
    );


    // Release cached frame.
    if ( frame_6c96b23369e54e55433f0730b526faa9 == cache_frame_6c96b23369e54e55433f0730b526faa9 )
    {
        Py_DECREF( frame_6c96b23369e54e55433f0730b526faa9 );
    }
    cache_frame_6c96b23369e54e55433f0730b526faa9 = NULL;

    assertFrameObject( frame_6c96b23369e54e55433f0730b526faa9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_61_libpd_compute_audio );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_flag );
    Py_DECREF( par_flag );
    par_flag = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_flag );
    Py_DECREF( par_flag );
    par_flag = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_61_libpd_compute_audio );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_62_libpd_release( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_p = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    struct Nuitka_FrameObject *frame_8e38145e52b56d5eb777ffae239d8856;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_8e38145e52b56d5eb777ffae239d8856 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8e38145e52b56d5eb777ffae239d8856, codeobj_8e38145e52b56d5eb777ffae239d8856, module_pylibpd, sizeof(void *) );
    frame_8e38145e52b56d5eb777ffae239d8856 = cache_frame_8e38145e52b56d5eb777ffae239d8856;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8e38145e52b56d5eb777ffae239d8856 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8e38145e52b56d5eb777ffae239d8856 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_patches );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_patches );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_patches" );
            exception_tb = NULL;

            exception_lineno = 335;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_8e38145e52b56d5eb777ffae239d8856->m_frame.f_lineno = 335;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_values );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 335;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "o";
                exception_lineno = 335;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_p;
            var_p = tmp_assign_source_3;
            Py_INCREF( var_p );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_closefile );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_closefile );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_closefile" );
            exception_tb = NULL;

            exception_lineno = 336;
            type_description_1 = "o";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_p );
        tmp_args_element_name_1 = var_p;
        frame_8e38145e52b56d5eb777ffae239d8856->m_frame.f_lineno = 336;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 336;
            type_description_1 = "o";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 335;
        type_description_1 = "o";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_patches );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_patches );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_patches" );
            exception_tb = NULL;

            exception_lineno = 337;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        frame_8e38145e52b56d5eb777ffae239d8856->m_frame.f_lineno = 337;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_clear );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 337;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_subscriptions" );
            exception_tb = NULL;

            exception_lineno = 338;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_4;
        frame_8e38145e52b56d5eb777ffae239d8856->m_frame.f_lineno = 338;
        tmp_iter_arg_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_values );
        if ( tmp_iter_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 338;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
        Py_DECREF( tmp_iter_arg_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 338;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_2__for_iterator == NULL );
        tmp_for_loop_2__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_2:;
    {
        PyObject *tmp_next_source_2;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_2__for_iterator );
        tmp_next_source_2 = tmp_for_loop_2__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_2;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "o";
                exception_lineno = 338;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_2__iter_value;
            tmp_for_loop_2__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_2__iter_value );
        tmp_assign_source_6 = tmp_for_loop_2__iter_value;
        {
            PyObject *old = var_p;
            var_p = tmp_assign_source_6;
            Py_INCREF( var_p );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_unbind );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_unbind );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_unbind" );
            exception_tb = NULL;

            exception_lineno = 339;
            type_description_1 = "o";
            goto try_except_handler_3;
        }

        tmp_called_name_2 = tmp_mvar_value_5;
        CHECK_OBJECT( var_p );
        tmp_args_element_name_2 = var_p;
        frame_8e38145e52b56d5eb777ffae239d8856->m_frame.f_lineno = 339;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 339;
            type_description_1 = "o";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 338;
        type_description_1 = "o";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_4;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "__libpd_subscriptions" );
            exception_tb = NULL;

            exception_lineno = 340;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_6;
        frame_8e38145e52b56d5eb777ffae239d8856->m_frame.f_lineno = 340;
        tmp_call_result_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_clear );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 340;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e38145e52b56d5eb777ffae239d8856 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e38145e52b56d5eb777ffae239d8856 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8e38145e52b56d5eb777ffae239d8856, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8e38145e52b56d5eb777ffae239d8856->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8e38145e52b56d5eb777ffae239d8856, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e38145e52b56d5eb777ffae239d8856,
        type_description_1,
        var_p
    );


    // Release cached frame.
    if ( frame_8e38145e52b56d5eb777ffae239d8856 == cache_frame_8e38145e52b56d5eb777ffae239d8856 )
    {
        Py_DECREF( frame_8e38145e52b56d5eb777ffae239d8856 );
    }
    cache_frame_8e38145e52b56d5eb777ffae239d8856 = NULL;

    assertFrameObject( frame_8e38145e52b56d5eb777ffae239d8856 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_62_libpd_release );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_p );
    var_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_p );
    var_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_62_libpd_release );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_63___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_inch = python_pars[ 1 ];
    PyObject *par_outch = python_pars[ 2 ];
    PyObject *par_srate = python_pars[ 3 ];
    PyObject *par_ticks = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_6ffef1c4183406a598a2b739920d352c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6ffef1c4183406a598a2b739920d352c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6ffef1c4183406a598a2b739920d352c, codeobj_6ffef1c4183406a598a2b739920d352c, module_pylibpd, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6ffef1c4183406a598a2b739920d352c = cache_frame_6ffef1c4183406a598a2b739920d352c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6ffef1c4183406a598a2b739920d352c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6ffef1c4183406a598a2b739920d352c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_ticks );
        tmp_assattr_name_1 = par_ticks;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__PdManager__ticks, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 344;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_array );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_array );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "array" );
            exception_tb = NULL;

            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_array );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_plain_h;
        tmp_left_name_2 = const_str_digest_d8498194b4aa4245dad6dd2c71b3dbb9;
        CHECK_OBJECT( par_outch );
        tmp_right_name_1 = par_outch;
        tmp_left_name_1 = BINARY_OPERATION_MUL( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_blocksize );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_libpd_blocksize );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "libpd_blocksize" );
            exception_tb = NULL;

            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        frame_6ffef1c4183406a598a2b739920d352c->m_frame.f_lineno = 345;
        tmp_right_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_6ffef1c4183406a598a2b739920d352c->m_frame.f_lineno = 345;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__PdManager__outbuf, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_compute_audio );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_libpd_compute_audio );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "libpd_compute_audio" );
            exception_tb = NULL;

            exception_lineno = 346;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        frame_6ffef1c4183406a598a2b739920d352c->m_frame.f_lineno = 346;
        tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_init_audio );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_libpd_init_audio );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "libpd_init_audio" );
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_4;
        CHECK_OBJECT( par_inch );
        tmp_args_element_name_3 = par_inch;
        CHECK_OBJECT( par_outch );
        tmp_args_element_name_4 = par_outch;
        CHECK_OBJECT( par_srate );
        tmp_args_element_name_5 = par_srate;
        frame_6ffef1c4183406a598a2b739920d352c->m_frame.f_lineno = 347;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 347;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ffef1c4183406a598a2b739920d352c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ffef1c4183406a598a2b739920d352c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6ffef1c4183406a598a2b739920d352c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6ffef1c4183406a598a2b739920d352c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6ffef1c4183406a598a2b739920d352c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6ffef1c4183406a598a2b739920d352c,
        type_description_1,
        par_self,
        par_inch,
        par_outch,
        par_srate,
        par_ticks
    );


    // Release cached frame.
    if ( frame_6ffef1c4183406a598a2b739920d352c == cache_frame_6ffef1c4183406a598a2b739920d352c )
    {
        Py_DECREF( frame_6ffef1c4183406a598a2b739920d352c );
    }
    cache_frame_6ffef1c4183406a598a2b739920d352c = NULL;

    assertFrameObject( frame_6ffef1c4183406a598a2b739920d352c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_63___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_inch );
    Py_DECREF( par_inch );
    par_inch = NULL;

    CHECK_OBJECT( (PyObject *)par_outch );
    Py_DECREF( par_outch );
    par_outch = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_srate );
    Py_DECREF( par_srate );
    par_srate = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_inch );
    Py_DECREF( par_inch );
    par_inch = NULL;

    CHECK_OBJECT( (PyObject *)par_outch );
    Py_DECREF( par_outch );
    par_outch = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ticks );
    Py_DECREF( par_ticks );
    par_ticks = NULL;

    CHECK_OBJECT( (PyObject *)par_srate );
    Py_DECREF( par_srate );
    par_srate = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_63___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_pylibpd$$$function_64_process( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_inbuf = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_160fd94ddde280b5cb4f44fbfad772ac;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_160fd94ddde280b5cb4f44fbfad772ac = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_160fd94ddde280b5cb4f44fbfad772ac, codeobj_160fd94ddde280b5cb4f44fbfad772ac, module_pylibpd, sizeof(void *)+sizeof(void *) );
    frame_160fd94ddde280b5cb4f44fbfad772ac = cache_frame_160fd94ddde280b5cb4f44fbfad772ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_160fd94ddde280b5cb4f44fbfad772ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_160fd94ddde280b5cb4f44fbfad772ac ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_short );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_libpd_process_short );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "libpd_process_short" );
            exception_tb = NULL;

            exception_lineno = 349;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__PdManager__ticks );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 349;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_inbuf );
        tmp_args_element_name_2 = par_inbuf;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__PdManager__outbuf );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 349;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_160fd94ddde280b5cb4f44fbfad772ac->m_frame.f_lineno = 349;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 349;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__PdManager__outbuf );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 350;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_160fd94ddde280b5cb4f44fbfad772ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_160fd94ddde280b5cb4f44fbfad772ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_160fd94ddde280b5cb4f44fbfad772ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_160fd94ddde280b5cb4f44fbfad772ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_160fd94ddde280b5cb4f44fbfad772ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_160fd94ddde280b5cb4f44fbfad772ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_160fd94ddde280b5cb4f44fbfad772ac,
        type_description_1,
        par_self,
        par_inbuf
    );


    // Release cached frame.
    if ( frame_160fd94ddde280b5cb4f44fbfad772ac == cache_frame_160fd94ddde280b5cb4f44fbfad772ac )
    {
        Py_DECREF( frame_160fd94ddde280b5cb4f44fbfad772ac );
    }
    cache_frame_160fd94ddde280b5cb4f44fbfad772ac = NULL;

    assertFrameObject( frame_160fd94ddde280b5cb4f44fbfad772ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_64_process );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_inbuf );
    Py_DECREF( par_inbuf );
    par_inbuf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_inbuf );
    Py_DECREF( par_inbuf );
    par_inbuf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pylibpd$$$function_64_process );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_10_libpd_init_audio(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_10_libpd_init_audio,
        const_str_plain_libpd_init_audio,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3504f5a87d2a4feec5f4942b8d92c36d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_11_libpd_process_raw(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_11_libpd_process_raw,
        const_str_plain_libpd_process_raw,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6a0ddd42e1b7a5a4152a4240159ad237,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_12_libpd_process_float(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_12_libpd_process_float,
        const_str_plain_libpd_process_float,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ac4c9fe1769bc11600950c3944287e34,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_13_libpd_process_short(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_13_libpd_process_short,
        const_str_plain_libpd_process_short,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e3b16727cdeb05738c4c9320beae9d9b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_14_libpd_process_double(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_14_libpd_process_double,
        const_str_plain_libpd_process_double,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0cb4bd587a57e70362d1db49a3a5990f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_15_libpd_arraysize(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_15_libpd_arraysize,
        const_str_plain_libpd_arraysize,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_071a47a91f9aed57f315c24786e5f01c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_16_libpd_read_array(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_16_libpd_read_array,
        const_str_plain_libpd_read_array,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6c62e24c2138b71b7592c5ef03e03f2e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_17_libpd_write_array(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_17_libpd_write_array,
        const_str_plain_libpd_write_array,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7488e77d04da376327f8b18b5284652a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_18_libpd_bang(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_18_libpd_bang,
        const_str_plain_libpd_bang,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f2ef16995e2a75890649eda2fadfb87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_19_libpd_float(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_19_libpd_float,
        const_str_plain_libpd_float,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e8f21a19af2747cccbab902149f03067,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_1_swig_import_helper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_1_swig_import_helper,
        const_str_plain_swig_import_helper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab62304def253682cced856ce07894d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_20_libpd_symbol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_20_libpd_symbol,
        const_str_plain_libpd_symbol,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cf2a7fe516656bccd925f44e5df336e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_21___libpd_start_message(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_21___libpd_start_message,
        const_str_plain___libpd_start_message,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_97a2f5f9b43c1ac5b38cdffb015ad2e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_22___libpd_add_float(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_22___libpd_add_float,
        const_str_plain___libpd_add_float,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f8a670eef22f494443ea2b9e7952c907,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_23___libpd_add_symbol(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_23___libpd_add_symbol,
        const_str_plain___libpd_add_symbol,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9409a7b93d94702a4a69920ae04eb161,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_24___libpd_finish_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_24___libpd_finish_list,
        const_str_plain___libpd_finish_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_172af12e7cacf671fefe4dc3cb40b952,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_25___libpd_finish_message(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_25___libpd_finish_message,
        const_str_plain___libpd_finish_message,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_08db12479674b55bb4e97286ce56e485,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_26_libpd_exists(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_26_libpd_exists,
        const_str_plain_libpd_exists,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d855202678d0be3f91372ec10aaf0bba,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_27___libpd_bind(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_27___libpd_bind,
        const_str_plain___libpd_bind,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_aca50b06b384550b93d83ce16d52d8bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_28___libpd_unbind(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_28___libpd_unbind,
        const_str_plain___libpd_unbind,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d29ead87806ceb2eb05c06e32cd27a0d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_29___libpd_openfile(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_29___libpd_openfile,
        const_str_plain___libpd_openfile,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ffe82fca45db6bdd4a31de8fd0802215,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_2_swig_import_helper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_2_swig_import_helper,
        const_str_plain_swig_import_helper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e45d2fa245588a22f6c5adeaa3e1bf1c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_30___libpd_closefile(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_30___libpd_closefile,
        const_str_plain___libpd_closefile,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_081627b32714c4dc4f79f1da7855cefe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_31___libpd_getdollarzero(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_31___libpd_getdollarzero,
        const_str_plain___libpd_getdollarzero,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7d03f83e6dcc89c3664b73e19d33999f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_32_libpd_noteon(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_32_libpd_noteon,
        const_str_plain_libpd_noteon,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6a6079783c9362b20448bac27358928a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_33_libpd_controlchange(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_33_libpd_controlchange,
        const_str_plain_libpd_controlchange,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_33b8c183561d8ad30ad8d6cc9e4f63ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_34_libpd_programchange(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_34_libpd_programchange,
        const_str_plain_libpd_programchange,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_02a37784f2b45c3c669122f5502c92b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_35_libpd_pitchbend(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_35_libpd_pitchbend,
        const_str_plain_libpd_pitchbend,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9b41b3f0701460461aebf73f01228470,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_36_libpd_aftertouch(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_36_libpd_aftertouch,
        const_str_plain_libpd_aftertouch,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0b068d00f991b4aa4c21b69db841c716,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_37_libpd_polyaftertouch(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_37_libpd_polyaftertouch,
        const_str_plain_libpd_polyaftertouch,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_76349622e9ca983d63f713959371dedd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_38_libpd_midibyte(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_38_libpd_midibyte,
        const_str_plain_libpd_midibyte,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c416fef52457d1894040227253d35001,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_39_libpd_sysex(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_39_libpd_sysex,
        const_str_plain_libpd_sysex,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b686d52c1e30b795289b80675fc8585e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_3__swig_setattr_nondynamic( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_3__swig_setattr_nondynamic,
        const_str_plain__swig_setattr_nondynamic,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c597563305462e9aa2ecc13cad43ab1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_40_libpd_sysrealtime(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_40_libpd_sysrealtime,
        const_str_plain_libpd_sysrealtime,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bfe583942d63a0207ea73d35a4df9663,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_41_libpd_set_print_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_41_libpd_set_print_callback,
        const_str_plain_libpd_set_print_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cc17d197781e6408060b20f3d83b6a4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_42_libpd_set_bang_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_42_libpd_set_bang_callback,
        const_str_plain_libpd_set_bang_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9f609cf12fb6702b215ca4e190df0150,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_43_libpd_set_float_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_43_libpd_set_float_callback,
        const_str_plain_libpd_set_float_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8386f14fa7ef7a1472148a612707d53d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_44_libpd_set_symbol_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_44_libpd_set_symbol_callback,
        const_str_plain_libpd_set_symbol_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_939b16de371ad68ae9b6bfb148332ccf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_45_libpd_set_list_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_45_libpd_set_list_callback,
        const_str_plain_libpd_set_list_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_49832756a35e30a84f59c4adf04e130d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_46_libpd_set_message_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_46_libpd_set_message_callback,
        const_str_plain_libpd_set_message_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d504bddcee8e4411a09cb993d761ed73,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_47_libpd_set_noteon_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_47_libpd_set_noteon_callback,
        const_str_plain_libpd_set_noteon_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_91e54d526b6875d6ecdee23c34416080,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_48_libpd_set_controlchange_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_48_libpd_set_controlchange_callback,
        const_str_plain_libpd_set_controlchange_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_93d9ddc9137f0c15be485242480929e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_49_libpd_set_programchange_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_49_libpd_set_programchange_callback,
        const_str_plain_libpd_set_programchange_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e98ce42509d553edec565b589a3402b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_4__swig_setattr(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_4__swig_setattr,
        const_str_plain__swig_setattr,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_31d62ac91c511fe21d095de46eb92ef7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_50_libpd_set_pitchbend_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_50_libpd_set_pitchbend_callback,
        const_str_plain_libpd_set_pitchbend_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2aa96112640cdd6d7ba59bfefe4d05bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_51_libpd_set_aftertouch_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_51_libpd_set_aftertouch_callback,
        const_str_plain_libpd_set_aftertouch_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0e508c26b2577e99373cc510f79d1d17,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_52_libpd_set_polyaftertouch_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_52_libpd_set_polyaftertouch_callback,
        const_str_plain_libpd_set_polyaftertouch_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a940df66d49765e4a3a3cce2004dbdf3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_53_libpd_set_midibyte_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_53_libpd_set_midibyte_callback,
        const_str_plain_libpd_set_midibyte_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_353278295782574f178182e484b36135,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_54___process_args(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_54___process_args,
        const_str_plain___process_args,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_38c0d26bc756e19052564548acf50807,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_55_libpd_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_55_libpd_list,
        const_str_plain_libpd_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_89383b11fa2394246d9479e8a9ffa0ce,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_56_libpd_message(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_56_libpd_message,
        const_str_plain_libpd_message,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d9975fdcb0550d907412bc2e53163472,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_57_libpd_open_patch( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_57_libpd_open_patch,
        const_str_plain_libpd_open_patch,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_134c2eef919a2e020ca576e89a1ef1b0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_58_libpd_close_patch(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_58_libpd_close_patch,
        const_str_plain_libpd_close_patch,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1cacc913ed2a0459d4ecf08b45761e89,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_59_libpd_subscribe(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_59_libpd_subscribe,
        const_str_plain_libpd_subscribe,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dfc3cb6cc00162b1590553f83958ba26,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_5__swig_getattr(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_5__swig_getattr,
        const_str_plain__swig_getattr,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ba9b8ae61fe4bb523340e957b1f4e083,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_60_libpd_unsubscribe(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_60_libpd_unsubscribe,
        const_str_plain_libpd_unsubscribe,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4b73e8b34ff0b182963b09d6f49d1972,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_61_libpd_compute_audio(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_61_libpd_compute_audio,
        const_str_plain_libpd_compute_audio,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6c96b23369e54e55433f0730b526faa9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_62_libpd_release(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_62_libpd_release,
        const_str_plain_libpd_release,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8e38145e52b56d5eb777ffae239d8856,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_63___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_63___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6ffef1c4183406a598a2b739920d352c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_64_process(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_64_process,
        const_str_plain_process,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_160fd94ddde280b5cb4f44fbfad772ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_6__swig_repr(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_6__swig_repr,
        const_str_plain__swig_repr,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9d7f64f4db8767f12bf73f9bbb96e593,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_7_libpd_clear_search_path(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_7_libpd_clear_search_path,
        const_str_plain_libpd_clear_search_path,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_343b5115a46b045f2a2143c29663c2cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_8_libpd_add_to_search_path(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_8_libpd_add_to_search_path,
        const_str_plain_libpd_add_to_search_path,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0aefc78e9fc9d2a532bc1b9369744774,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pylibpd$$$function_9_libpd_blocksize(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pylibpd$$$function_9_libpd_blocksize,
        const_str_plain_libpd_blocksize,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_acf27e75a7097025445ee5215c567823,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_pylibpd,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_pylibpd =
{
    PyModuleDef_HEAD_INIT,
    "pylibpd",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;

extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( pylibpd )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_pylibpd );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("pylibpd: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("pylibpd: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("pylibpd: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initpylibpd" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_pylibpd = Py_InitModule4(
        "pylibpd",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_pylibpd = PyModule_Create( &mdef_pylibpd );
#endif

    moduledict_pylibpd = MODULE_DICT( module_pylibpd );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_pylibpd,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_pylibpd,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_pylibpd,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_pylibpd );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_plain_pylibpd, module_pylibpd );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_locals_pylibpd_342_key___init__ = NULL;
    PyObject *tmp_locals_pylibpd_342_key_process = NULL;
    struct Nuitka_FrameObject *frame_c874ce24acba0c1b5e4d06071c656789;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_49aeafda3f6d3de6fe167dc090ca3880;
        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_sys;
        tmp_globals_name_1 = (PyObject *)moduledict_pylibpd;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_version_info_tuple;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        assert( !(tmp_import_name_from_1 == NULL) );
        tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_version_info );
        Py_DECREF( tmp_import_name_from_1 );
        assert( !(tmp_assign_source_3 == NULL) );
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_python_version_info, tmp_assign_source_3 );
    }
    // Frame without reuse.
    frame_c874ce24acba0c1b5e4d06071c656789 = MAKE_MODULE_FRAME( codeobj_c874ce24acba0c1b5e4d06071c656789, module_pylibpd );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_c874ce24acba0c1b5e4d06071c656789 );
    assert( Py_REFCNT( frame_c874ce24acba0c1b5e4d06071c656789 ) == 2 );

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_python_version_info );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__swig_python_version_info );
        }

        CHECK_OBJECT( tmp_mvar_value_1 );
        tmp_compexpr_left_1 = tmp_mvar_value_1;
        tmp_compexpr_right_1 = const_tuple_int_pos_2_int_pos_7_int_0_tuple;
        tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 8;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = MAKE_FUNCTION_pylibpd$$$function_1_swig_import_helper(  );



            UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_swig_import_helper, tmp_assign_source_4 );
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_swig_import_helper );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_swig_import_helper );
            }

            CHECK_OBJECT( tmp_mvar_value_2 );
            tmp_called_name_1 = tmp_mvar_value_2;
            frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 17;
            tmp_assign_source_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 17;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd, tmp_assign_source_5 );
        }
        tmp_res = PyDict_DelItem( (PyObject *)moduledict_pylibpd, const_str_plain_swig_import_helper );
        tmp_result = tmp_res != -1;
        if ( tmp_result == false ) CLEAR_ERROR_OCCURRED();

        if ( tmp_result == false )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "swig_import_helper" );
            exception_tb = NULL;

            exception_lineno = 18;

            goto frame_exception_exit_1;
        }

        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_python_version_info );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__swig_python_version_info );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_swig_python_version_info" );
                exception_tb = NULL;

                exception_lineno = 19;

                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_2 = tmp_mvar_value_3;
            tmp_compexpr_right_2 = const_tuple_int_pos_2_int_pos_6_int_0_tuple;
            tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 19;

                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_6;
                tmp_assign_source_6 = MAKE_FUNCTION_pylibpd$$$function_2_swig_import_helper(  );



                UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_swig_import_helper, tmp_assign_source_6 );
            }
            {
                PyObject *tmp_assign_source_7;
                PyObject *tmp_called_name_2;
                PyObject *tmp_mvar_value_4;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_swig_import_helper );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_swig_import_helper );
                }

                CHECK_OBJECT( tmp_mvar_value_4 );
                tmp_called_name_2 = tmp_mvar_value_4;
                frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 35;
                tmp_assign_source_7 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
                if ( tmp_assign_source_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 35;

                    goto frame_exception_exit_1;
                }
                UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd, tmp_assign_source_7 );
            }
            tmp_res = PyDict_DelItem( (PyObject *)moduledict_pylibpd, const_str_plain_swig_import_helper );
            tmp_result = tmp_res != -1;
            if ( tmp_result == false ) CLEAR_ERROR_OCCURRED();

            if ( tmp_result == false )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "swig_import_helper" );
                exception_tb = NULL;

                exception_lineno = 36;

                goto frame_exception_exit_1;
            }

            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_name_name_2;
                PyObject *tmp_globals_name_2;
                PyObject *tmp_locals_name_2;
                PyObject *tmp_fromlist_name_2;
                tmp_name_name_2 = const_str_plain__pylibpd;
                tmp_globals_name_2 = (PyObject *)moduledict_pylibpd;
                tmp_locals_name_2 = Py_None;
                tmp_fromlist_name_2 = Py_None;
                frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 38;
                tmp_assign_source_8 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
                if ( tmp_assign_source_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 38;

                    goto frame_exception_exit_1;
                }
                UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd, tmp_assign_source_8 );
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_pylibpd, const_str_plain__swig_python_version_info );
    tmp_result = tmp_res != -1;
    if ( tmp_result == false ) CLEAR_ERROR_OCCURRED();

    if ( tmp_result == false )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "_swig_python_version_info" );
        exception_tb = NULL;

        exception_lineno = 39;

        goto frame_exception_exit_1;
    }

    {
        PyObject *tmp_assign_source_9;
        tmp_assign_source_9 = (PyObject *)&PyProperty_Type;
        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_property, tmp_assign_source_9 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        tmp_name_name_3 = const_str_plain_builtins;
        tmp_globals_name_3 = (PyObject *)moduledict_pylibpd;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = Py_None;
        frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 47;
        tmp_assign_source_10 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 47;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___builtin__, tmp_assign_source_10 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_c874ce24acba0c1b5e4d06071c656789 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_c874ce24acba0c1b5e4d06071c656789, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_c874ce24acba0c1b5e4d06071c656789, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_ImportError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 48;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_name_name_4;
            PyObject *tmp_globals_name_4;
            PyObject *tmp_locals_name_4;
            PyObject *tmp_fromlist_name_4;
            tmp_name_name_4 = const_str_plain___builtin__;
            tmp_globals_name_4 = (PyObject *)moduledict_pylibpd;
            tmp_locals_name_4 = Py_None;
            tmp_fromlist_name_4 = Py_None;
            frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 49;
            tmp_assign_source_11 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
            assert( !(tmp_assign_source_11 == NULL) );
            UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___builtin__, tmp_assign_source_11 );
        }
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 46;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_c874ce24acba0c1b5e4d06071c656789->m_frame) frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = exception_tb->tb_lineno;

        goto frame_exception_exit_1;
        branch_end_3:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pylibpd );
    return MOD_RETURN_VALUE( NULL );
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_defaults_1;
        tmp_defaults_1 = const_tuple_int_pos_1_tuple;
        Py_INCREF( tmp_defaults_1 );
        tmp_assign_source_12 = MAKE_FUNCTION_pylibpd$$$function_3__swig_setattr_nondynamic( tmp_defaults_1 );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_setattr_nondynamic, tmp_assign_source_12 );
    }
    {
        PyObject *tmp_assign_source_13;
        tmp_assign_source_13 = MAKE_FUNCTION_pylibpd$$$function_4__swig_setattr(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_setattr, tmp_assign_source_13 );
    }
    {
        PyObject *tmp_assign_source_14;
        tmp_assign_source_14 = MAKE_FUNCTION_pylibpd$$$function_5__swig_getattr(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_getattr, tmp_assign_source_14 );
    }
    {
        PyObject *tmp_assign_source_15;
        tmp_assign_source_15 = MAKE_FUNCTION_pylibpd$$$function_6__swig_repr(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__swig_repr, tmp_assign_source_15 );
    }
    {
        PyObject *tmp_assign_source_16;
        tmp_assign_source_16 = (PyObject *)&PyBaseObject_Type;
        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__object, tmp_assign_source_16 );
    }
    {
        PyObject *tmp_assign_source_17;
        tmp_assign_source_17 = const_int_pos_1;
        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__newclass, tmp_assign_source_17 );
    }
    {
        PyObject *tmp_assign_source_18;
        tmp_assign_source_18 = MAKE_FUNCTION_pylibpd$$$function_7_libpd_clear_search_path(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_clear_search_path, tmp_assign_source_18 );
    }
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 101;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_5;
        tmp_assign_source_19 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_libpd_clear_search_path );
        if ( tmp_assign_source_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 101;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_clear_search_path, tmp_assign_source_19 );
    }
    {
        PyObject *tmp_assign_source_20;
        tmp_assign_source_20 = MAKE_FUNCTION_pylibpd$$$function_8_libpd_add_to_search_path(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_add_to_search_path, tmp_assign_source_20 );
    }
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 105;

            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_6;
        tmp_assign_source_21 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_libpd_add_to_search_path );
        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 105;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_add_to_search_path, tmp_assign_source_21 );
    }
    {
        PyObject *tmp_assign_source_22;
        tmp_assign_source_22 = MAKE_FUNCTION_pylibpd$$$function_9_libpd_blocksize(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_blocksize, tmp_assign_source_22 );
    }
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 109;

            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_7;
        tmp_assign_source_23 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_libpd_blocksize );
        if ( tmp_assign_source_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 109;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_blocksize, tmp_assign_source_23 );
    }
    {
        PyObject *tmp_assign_source_24;
        tmp_assign_source_24 = MAKE_FUNCTION_pylibpd$$$function_10_libpd_init_audio(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_init_audio, tmp_assign_source_24 );
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 113;

            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_8;
        tmp_assign_source_25 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_libpd_init_audio );
        if ( tmp_assign_source_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 113;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_init_audio, tmp_assign_source_25 );
    }
    {
        PyObject *tmp_assign_source_26;
        tmp_assign_source_26 = MAKE_FUNCTION_pylibpd$$$function_11_libpd_process_raw(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_raw, tmp_assign_source_26 );
    }
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 117;

            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_9;
        tmp_assign_source_27 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_libpd_process_raw );
        if ( tmp_assign_source_27 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 117;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_raw, tmp_assign_source_27 );
    }
    {
        PyObject *tmp_assign_source_28;
        tmp_assign_source_28 = MAKE_FUNCTION_pylibpd$$$function_12_libpd_process_float(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_float, tmp_assign_source_28 );
    }
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 121;

            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_assign_source_29 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_libpd_process_float );
        if ( tmp_assign_source_29 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 121;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_float, tmp_assign_source_29 );
    }
    {
        PyObject *tmp_assign_source_30;
        tmp_assign_source_30 = MAKE_FUNCTION_pylibpd$$$function_13_libpd_process_short(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_short, tmp_assign_source_30 );
    }
    {
        PyObject *tmp_assign_source_31;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 125;

            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_assign_source_31 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_libpd_process_short );
        if ( tmp_assign_source_31 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_short, tmp_assign_source_31 );
    }
    {
        PyObject *tmp_assign_source_32;
        tmp_assign_source_32 = MAKE_FUNCTION_pylibpd$$$function_14_libpd_process_double(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_double, tmp_assign_source_32 );
    }
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 129;

            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_12;
        tmp_assign_source_33 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_libpd_process_double );
        if ( tmp_assign_source_33 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_process_double, tmp_assign_source_33 );
    }
    {
        PyObject *tmp_assign_source_34;
        tmp_assign_source_34 = MAKE_FUNCTION_pylibpd$$$function_15_libpd_arraysize(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_arraysize, tmp_assign_source_34 );
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 133;

            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_13;
        tmp_assign_source_35 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_libpd_arraysize );
        if ( tmp_assign_source_35 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 133;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_arraysize, tmp_assign_source_35 );
    }
    {
        PyObject *tmp_assign_source_36;
        tmp_assign_source_36 = MAKE_FUNCTION_pylibpd$$$function_16_libpd_read_array(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_read_array, tmp_assign_source_36 );
    }
    {
        PyObject *tmp_assign_source_37;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 137;

            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_14;
        tmp_assign_source_37 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_libpd_read_array );
        if ( tmp_assign_source_37 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 137;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_read_array, tmp_assign_source_37 );
    }
    {
        PyObject *tmp_assign_source_38;
        tmp_assign_source_38 = MAKE_FUNCTION_pylibpd$$$function_17_libpd_write_array(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_write_array, tmp_assign_source_38 );
    }
    {
        PyObject *tmp_assign_source_39;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_15;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 141;

            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_15;
        tmp_assign_source_39 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_libpd_write_array );
        if ( tmp_assign_source_39 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_write_array, tmp_assign_source_39 );
    }
    {
        PyObject *tmp_assign_source_40;
        tmp_assign_source_40 = MAKE_FUNCTION_pylibpd$$$function_18_libpd_bang(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_bang, tmp_assign_source_40 );
    }
    {
        PyObject *tmp_assign_source_41;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_16;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 145;

            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_16;
        tmp_assign_source_41 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_libpd_bang );
        if ( tmp_assign_source_41 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 145;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_bang, tmp_assign_source_41 );
    }
    {
        PyObject *tmp_assign_source_42;
        tmp_assign_source_42 = MAKE_FUNCTION_pylibpd$$$function_19_libpd_float(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_float, tmp_assign_source_42 );
    }
    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_source_name_13;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_17 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 149;

            goto frame_exception_exit_1;
        }

        tmp_source_name_13 = tmp_mvar_value_17;
        tmp_assign_source_43 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_libpd_float );
        if ( tmp_assign_source_43 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_float, tmp_assign_source_43 );
    }
    {
        PyObject *tmp_assign_source_44;
        tmp_assign_source_44 = MAKE_FUNCTION_pylibpd$$$function_20_libpd_symbol(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_symbol, tmp_assign_source_44 );
    }
    {
        PyObject *tmp_assign_source_45;
        PyObject *tmp_source_name_14;
        PyObject *tmp_mvar_value_18;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_18 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 153;

            goto frame_exception_exit_1;
        }

        tmp_source_name_14 = tmp_mvar_value_18;
        tmp_assign_source_45 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_libpd_symbol );
        if ( tmp_assign_source_45 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_symbol, tmp_assign_source_45 );
    }
    {
        PyObject *tmp_assign_source_46;
        tmp_assign_source_46 = MAKE_FUNCTION_pylibpd$$$function_21___libpd_start_message(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_start_message, tmp_assign_source_46 );
    }
    {
        PyObject *tmp_assign_source_47;
        PyObject *tmp_source_name_15;
        PyObject *tmp_mvar_value_19;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 157;

            goto frame_exception_exit_1;
        }

        tmp_source_name_15 = tmp_mvar_value_19;
        tmp_assign_source_47 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain___libpd_start_message );
        if ( tmp_assign_source_47 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 157;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_start_message, tmp_assign_source_47 );
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = MAKE_FUNCTION_pylibpd$$$function_22___libpd_add_float(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_add_float, tmp_assign_source_48 );
    }
    {
        PyObject *tmp_assign_source_49;
        PyObject *tmp_source_name_16;
        PyObject *tmp_mvar_value_20;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_20 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 161;

            goto frame_exception_exit_1;
        }

        tmp_source_name_16 = tmp_mvar_value_20;
        tmp_assign_source_49 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain___libpd_add_float );
        if ( tmp_assign_source_49 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 161;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_add_float, tmp_assign_source_49 );
    }
    {
        PyObject *tmp_assign_source_50;
        tmp_assign_source_50 = MAKE_FUNCTION_pylibpd$$$function_23___libpd_add_symbol(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_add_symbol, tmp_assign_source_50 );
    }
    {
        PyObject *tmp_assign_source_51;
        PyObject *tmp_source_name_17;
        PyObject *tmp_mvar_value_21;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_21 == NULL ))
        {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_21 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 165;

            goto frame_exception_exit_1;
        }

        tmp_source_name_17 = tmp_mvar_value_21;
        tmp_assign_source_51 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain___libpd_add_symbol );
        if ( tmp_assign_source_51 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_add_symbol, tmp_assign_source_51 );
    }
    {
        PyObject *tmp_assign_source_52;
        tmp_assign_source_52 = MAKE_FUNCTION_pylibpd$$$function_24___libpd_finish_list(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_finish_list, tmp_assign_source_52 );
    }
    {
        PyObject *tmp_assign_source_53;
        PyObject *tmp_source_name_18;
        PyObject *tmp_mvar_value_22;
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_22 == NULL ))
        {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_22 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 169;

            goto frame_exception_exit_1;
        }

        tmp_source_name_18 = tmp_mvar_value_22;
        tmp_assign_source_53 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain___libpd_finish_list );
        if ( tmp_assign_source_53 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 169;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_finish_list, tmp_assign_source_53 );
    }
    {
        PyObject *tmp_assign_source_54;
        tmp_assign_source_54 = MAKE_FUNCTION_pylibpd$$$function_25___libpd_finish_message(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_finish_message, tmp_assign_source_54 );
    }
    {
        PyObject *tmp_assign_source_55;
        PyObject *tmp_source_name_19;
        PyObject *tmp_mvar_value_23;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_23 == NULL ))
        {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_23 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 173;

            goto frame_exception_exit_1;
        }

        tmp_source_name_19 = tmp_mvar_value_23;
        tmp_assign_source_55 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain___libpd_finish_message );
        if ( tmp_assign_source_55 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 173;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_finish_message, tmp_assign_source_55 );
    }
    {
        PyObject *tmp_assign_source_56;
        tmp_assign_source_56 = MAKE_FUNCTION_pylibpd$$$function_26_libpd_exists(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_exists, tmp_assign_source_56 );
    }
    {
        PyObject *tmp_assign_source_57;
        PyObject *tmp_source_name_20;
        PyObject *tmp_mvar_value_24;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_24 == NULL ))
        {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_24 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 177;

            goto frame_exception_exit_1;
        }

        tmp_source_name_20 = tmp_mvar_value_24;
        tmp_assign_source_57 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_libpd_exists );
        if ( tmp_assign_source_57 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 177;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_exists, tmp_assign_source_57 );
    }
    {
        PyObject *tmp_assign_source_58;
        tmp_assign_source_58 = MAKE_FUNCTION_pylibpd$$$function_27___libpd_bind(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_bind, tmp_assign_source_58 );
    }
    {
        PyObject *tmp_assign_source_59;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_25;
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_25 == NULL ))
        {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_25 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 181;

            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_25;
        tmp_assign_source_59 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain___libpd_bind );
        if ( tmp_assign_source_59 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 181;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_bind, tmp_assign_source_59 );
    }
    {
        PyObject *tmp_assign_source_60;
        tmp_assign_source_60 = MAKE_FUNCTION_pylibpd$$$function_28___libpd_unbind(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_unbind, tmp_assign_source_60 );
    }
    {
        PyObject *tmp_assign_source_61;
        PyObject *tmp_source_name_22;
        PyObject *tmp_mvar_value_26;
        tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_26 == NULL ))
        {
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_26 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 185;

            goto frame_exception_exit_1;
        }

        tmp_source_name_22 = tmp_mvar_value_26;
        tmp_assign_source_61 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain___libpd_unbind );
        if ( tmp_assign_source_61 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 185;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_unbind, tmp_assign_source_61 );
    }
    {
        PyObject *tmp_assign_source_62;
        tmp_assign_source_62 = MAKE_FUNCTION_pylibpd$$$function_29___libpd_openfile(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_openfile, tmp_assign_source_62 );
    }
    {
        PyObject *tmp_assign_source_63;
        PyObject *tmp_source_name_23;
        PyObject *tmp_mvar_value_27;
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_27 == NULL ))
        {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_27 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 189;

            goto frame_exception_exit_1;
        }

        tmp_source_name_23 = tmp_mvar_value_27;
        tmp_assign_source_63 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain___libpd_openfile );
        if ( tmp_assign_source_63 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 189;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_openfile, tmp_assign_source_63 );
    }
    {
        PyObject *tmp_assign_source_64;
        tmp_assign_source_64 = MAKE_FUNCTION_pylibpd$$$function_30___libpd_closefile(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_closefile, tmp_assign_source_64 );
    }
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_source_name_24;
        PyObject *tmp_mvar_value_28;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_28 == NULL ))
        {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_28 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 193;

            goto frame_exception_exit_1;
        }

        tmp_source_name_24 = tmp_mvar_value_28;
        tmp_assign_source_65 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain___libpd_closefile );
        if ( tmp_assign_source_65 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 193;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_closefile, tmp_assign_source_65 );
    }
    {
        PyObject *tmp_assign_source_66;
        tmp_assign_source_66 = MAKE_FUNCTION_pylibpd$$$function_31___libpd_getdollarzero(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_getdollarzero, tmp_assign_source_66 );
    }
    {
        PyObject *tmp_assign_source_67;
        PyObject *tmp_source_name_25;
        PyObject *tmp_mvar_value_29;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_29 == NULL ))
        {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_29 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 197;

            goto frame_exception_exit_1;
        }

        tmp_source_name_25 = tmp_mvar_value_29;
        tmp_assign_source_67 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain___libpd_getdollarzero );
        if ( tmp_assign_source_67 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 197;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_getdollarzero, tmp_assign_source_67 );
    }
    {
        PyObject *tmp_assign_source_68;
        tmp_assign_source_68 = MAKE_FUNCTION_pylibpd$$$function_32_libpd_noteon(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_noteon, tmp_assign_source_68 );
    }
    {
        PyObject *tmp_assign_source_69;
        PyObject *tmp_source_name_26;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_30 == NULL ))
        {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_30 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 201;

            goto frame_exception_exit_1;
        }

        tmp_source_name_26 = tmp_mvar_value_30;
        tmp_assign_source_69 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_libpd_noteon );
        if ( tmp_assign_source_69 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 201;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_noteon, tmp_assign_source_69 );
    }
    {
        PyObject *tmp_assign_source_70;
        tmp_assign_source_70 = MAKE_FUNCTION_pylibpd$$$function_33_libpd_controlchange(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_controlchange, tmp_assign_source_70 );
    }
    {
        PyObject *tmp_assign_source_71;
        PyObject *tmp_source_name_27;
        PyObject *tmp_mvar_value_31;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_31 == NULL ))
        {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_31 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 205;

            goto frame_exception_exit_1;
        }

        tmp_source_name_27 = tmp_mvar_value_31;
        tmp_assign_source_71 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_libpd_controlchange );
        if ( tmp_assign_source_71 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 205;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_controlchange, tmp_assign_source_71 );
    }
    {
        PyObject *tmp_assign_source_72;
        tmp_assign_source_72 = MAKE_FUNCTION_pylibpd$$$function_34_libpd_programchange(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_programchange, tmp_assign_source_72 );
    }
    {
        PyObject *tmp_assign_source_73;
        PyObject *tmp_source_name_28;
        PyObject *tmp_mvar_value_32;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_32 == NULL ))
        {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_32 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 209;

            goto frame_exception_exit_1;
        }

        tmp_source_name_28 = tmp_mvar_value_32;
        tmp_assign_source_73 = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain_libpd_programchange );
        if ( tmp_assign_source_73 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 209;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_programchange, tmp_assign_source_73 );
    }
    {
        PyObject *tmp_assign_source_74;
        tmp_assign_source_74 = MAKE_FUNCTION_pylibpd$$$function_35_libpd_pitchbend(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_pitchbend, tmp_assign_source_74 );
    }
    {
        PyObject *tmp_assign_source_75;
        PyObject *tmp_source_name_29;
        PyObject *tmp_mvar_value_33;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 213;

            goto frame_exception_exit_1;
        }

        tmp_source_name_29 = tmp_mvar_value_33;
        tmp_assign_source_75 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain_libpd_pitchbend );
        if ( tmp_assign_source_75 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 213;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_pitchbend, tmp_assign_source_75 );
    }
    {
        PyObject *tmp_assign_source_76;
        tmp_assign_source_76 = MAKE_FUNCTION_pylibpd$$$function_36_libpd_aftertouch(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_aftertouch, tmp_assign_source_76 );
    }
    {
        PyObject *tmp_assign_source_77;
        PyObject *tmp_source_name_30;
        PyObject *tmp_mvar_value_34;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 217;

            goto frame_exception_exit_1;
        }

        tmp_source_name_30 = tmp_mvar_value_34;
        tmp_assign_source_77 = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain_libpd_aftertouch );
        if ( tmp_assign_source_77 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 217;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_aftertouch, tmp_assign_source_77 );
    }
    {
        PyObject *tmp_assign_source_78;
        tmp_assign_source_78 = MAKE_FUNCTION_pylibpd$$$function_37_libpd_polyaftertouch(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_polyaftertouch, tmp_assign_source_78 );
    }
    {
        PyObject *tmp_assign_source_79;
        PyObject *tmp_source_name_31;
        PyObject *tmp_mvar_value_35;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_35 == NULL ))
        {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_35 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 221;

            goto frame_exception_exit_1;
        }

        tmp_source_name_31 = tmp_mvar_value_35;
        tmp_assign_source_79 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain_libpd_polyaftertouch );
        if ( tmp_assign_source_79 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 221;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_polyaftertouch, tmp_assign_source_79 );
    }
    {
        PyObject *tmp_assign_source_80;
        tmp_assign_source_80 = MAKE_FUNCTION_pylibpd$$$function_38_libpd_midibyte(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_midibyte, tmp_assign_source_80 );
    }
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_source_name_32;
        PyObject *tmp_mvar_value_36;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_36 == NULL ))
        {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_36 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 225;

            goto frame_exception_exit_1;
        }

        tmp_source_name_32 = tmp_mvar_value_36;
        tmp_assign_source_81 = LOOKUP_ATTRIBUTE( tmp_source_name_32, const_str_plain_libpd_midibyte );
        if ( tmp_assign_source_81 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 225;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_midibyte, tmp_assign_source_81 );
    }
    {
        PyObject *tmp_assign_source_82;
        tmp_assign_source_82 = MAKE_FUNCTION_pylibpd$$$function_39_libpd_sysex(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_sysex, tmp_assign_source_82 );
    }
    {
        PyObject *tmp_assign_source_83;
        PyObject *tmp_source_name_33;
        PyObject *tmp_mvar_value_37;
        tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_37 == NULL ))
        {
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_37 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 229;

            goto frame_exception_exit_1;
        }

        tmp_source_name_33 = tmp_mvar_value_37;
        tmp_assign_source_83 = LOOKUP_ATTRIBUTE( tmp_source_name_33, const_str_plain_libpd_sysex );
        if ( tmp_assign_source_83 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 229;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_sysex, tmp_assign_source_83 );
    }
    {
        PyObject *tmp_assign_source_84;
        tmp_assign_source_84 = MAKE_FUNCTION_pylibpd$$$function_40_libpd_sysrealtime(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_sysrealtime, tmp_assign_source_84 );
    }
    {
        PyObject *tmp_assign_source_85;
        PyObject *tmp_source_name_34;
        PyObject *tmp_mvar_value_38;
        tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_38 == NULL ))
        {
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_38 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 233;

            goto frame_exception_exit_1;
        }

        tmp_source_name_34 = tmp_mvar_value_38;
        tmp_assign_source_85 = LOOKUP_ATTRIBUTE( tmp_source_name_34, const_str_plain_libpd_sysrealtime );
        if ( tmp_assign_source_85 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 233;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_sysrealtime, tmp_assign_source_85 );
    }
    {
        PyObject *tmp_assign_source_86;
        tmp_assign_source_86 = MAKE_FUNCTION_pylibpd$$$function_41_libpd_set_print_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_print_callback, tmp_assign_source_86 );
    }
    {
        PyObject *tmp_assign_source_87;
        PyObject *tmp_source_name_35;
        PyObject *tmp_mvar_value_39;
        tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_39 == NULL ))
        {
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_39 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 237;

            goto frame_exception_exit_1;
        }

        tmp_source_name_35 = tmp_mvar_value_39;
        tmp_assign_source_87 = LOOKUP_ATTRIBUTE( tmp_source_name_35, const_str_plain_libpd_set_print_callback );
        if ( tmp_assign_source_87 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 237;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_print_callback, tmp_assign_source_87 );
    }
    {
        PyObject *tmp_assign_source_88;
        tmp_assign_source_88 = MAKE_FUNCTION_pylibpd$$$function_42_libpd_set_bang_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_bang_callback, tmp_assign_source_88 );
    }
    {
        PyObject *tmp_assign_source_89;
        PyObject *tmp_source_name_36;
        PyObject *tmp_mvar_value_40;
        tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_40 == NULL ))
        {
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_40 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 241;

            goto frame_exception_exit_1;
        }

        tmp_source_name_36 = tmp_mvar_value_40;
        tmp_assign_source_89 = LOOKUP_ATTRIBUTE( tmp_source_name_36, const_str_plain_libpd_set_bang_callback );
        if ( tmp_assign_source_89 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 241;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_bang_callback, tmp_assign_source_89 );
    }
    {
        PyObject *tmp_assign_source_90;
        tmp_assign_source_90 = MAKE_FUNCTION_pylibpd$$$function_43_libpd_set_float_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_float_callback, tmp_assign_source_90 );
    }
    {
        PyObject *tmp_assign_source_91;
        PyObject *tmp_source_name_37;
        PyObject *tmp_mvar_value_41;
        tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_41 == NULL ))
        {
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_41 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_source_name_37 = tmp_mvar_value_41;
        tmp_assign_source_91 = LOOKUP_ATTRIBUTE( tmp_source_name_37, const_str_plain_libpd_set_float_callback );
        if ( tmp_assign_source_91 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 245;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_float_callback, tmp_assign_source_91 );
    }
    {
        PyObject *tmp_assign_source_92;
        tmp_assign_source_92 = MAKE_FUNCTION_pylibpd$$$function_44_libpd_set_symbol_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_symbol_callback, tmp_assign_source_92 );
    }
    {
        PyObject *tmp_assign_source_93;
        PyObject *tmp_source_name_38;
        PyObject *tmp_mvar_value_42;
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_42 == NULL ))
        {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_42 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 249;

            goto frame_exception_exit_1;
        }

        tmp_source_name_38 = tmp_mvar_value_42;
        tmp_assign_source_93 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain_libpd_set_symbol_callback );
        if ( tmp_assign_source_93 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 249;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_symbol_callback, tmp_assign_source_93 );
    }
    {
        PyObject *tmp_assign_source_94;
        tmp_assign_source_94 = MAKE_FUNCTION_pylibpd$$$function_45_libpd_set_list_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_list_callback, tmp_assign_source_94 );
    }
    {
        PyObject *tmp_assign_source_95;
        PyObject *tmp_source_name_39;
        PyObject *tmp_mvar_value_43;
        tmp_mvar_value_43 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_43 == NULL ))
        {
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_43 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 253;

            goto frame_exception_exit_1;
        }

        tmp_source_name_39 = tmp_mvar_value_43;
        tmp_assign_source_95 = LOOKUP_ATTRIBUTE( tmp_source_name_39, const_str_plain_libpd_set_list_callback );
        if ( tmp_assign_source_95 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 253;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_list_callback, tmp_assign_source_95 );
    }
    {
        PyObject *tmp_assign_source_96;
        tmp_assign_source_96 = MAKE_FUNCTION_pylibpd$$$function_46_libpd_set_message_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_message_callback, tmp_assign_source_96 );
    }
    {
        PyObject *tmp_assign_source_97;
        PyObject *tmp_source_name_40;
        PyObject *tmp_mvar_value_44;
        tmp_mvar_value_44 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_44 == NULL ))
        {
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_44 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 257;

            goto frame_exception_exit_1;
        }

        tmp_source_name_40 = tmp_mvar_value_44;
        tmp_assign_source_97 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain_libpd_set_message_callback );
        if ( tmp_assign_source_97 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 257;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_message_callback, tmp_assign_source_97 );
    }
    {
        PyObject *tmp_assign_source_98;
        tmp_assign_source_98 = MAKE_FUNCTION_pylibpd$$$function_47_libpd_set_noteon_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_noteon_callback, tmp_assign_source_98 );
    }
    {
        PyObject *tmp_assign_source_99;
        PyObject *tmp_source_name_41;
        PyObject *tmp_mvar_value_45;
        tmp_mvar_value_45 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_45 == NULL ))
        {
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_45 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 261;

            goto frame_exception_exit_1;
        }

        tmp_source_name_41 = tmp_mvar_value_45;
        tmp_assign_source_99 = LOOKUP_ATTRIBUTE( tmp_source_name_41, const_str_plain_libpd_set_noteon_callback );
        if ( tmp_assign_source_99 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_noteon_callback, tmp_assign_source_99 );
    }
    {
        PyObject *tmp_assign_source_100;
        tmp_assign_source_100 = MAKE_FUNCTION_pylibpd$$$function_48_libpd_set_controlchange_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_controlchange_callback, tmp_assign_source_100 );
    }
    {
        PyObject *tmp_assign_source_101;
        PyObject *tmp_source_name_42;
        PyObject *tmp_mvar_value_46;
        tmp_mvar_value_46 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_46 == NULL ))
        {
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_46 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 265;

            goto frame_exception_exit_1;
        }

        tmp_source_name_42 = tmp_mvar_value_46;
        tmp_assign_source_101 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain_libpd_set_controlchange_callback );
        if ( tmp_assign_source_101 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 265;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_controlchange_callback, tmp_assign_source_101 );
    }
    {
        PyObject *tmp_assign_source_102;
        tmp_assign_source_102 = MAKE_FUNCTION_pylibpd$$$function_49_libpd_set_programchange_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_programchange_callback, tmp_assign_source_102 );
    }
    {
        PyObject *tmp_assign_source_103;
        PyObject *tmp_source_name_43;
        PyObject *tmp_mvar_value_47;
        tmp_mvar_value_47 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_47 == NULL ))
        {
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_47 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 269;

            goto frame_exception_exit_1;
        }

        tmp_source_name_43 = tmp_mvar_value_47;
        tmp_assign_source_103 = LOOKUP_ATTRIBUTE( tmp_source_name_43, const_str_plain_libpd_set_programchange_callback );
        if ( tmp_assign_source_103 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 269;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_programchange_callback, tmp_assign_source_103 );
    }
    {
        PyObject *tmp_assign_source_104;
        tmp_assign_source_104 = MAKE_FUNCTION_pylibpd$$$function_50_libpd_set_pitchbend_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_pitchbend_callback, tmp_assign_source_104 );
    }
    {
        PyObject *tmp_assign_source_105;
        PyObject *tmp_source_name_44;
        PyObject *tmp_mvar_value_48;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_48 == NULL ))
        {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_48 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 273;

            goto frame_exception_exit_1;
        }

        tmp_source_name_44 = tmp_mvar_value_48;
        tmp_assign_source_105 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain_libpd_set_pitchbend_callback );
        if ( tmp_assign_source_105 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 273;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_pitchbend_callback, tmp_assign_source_105 );
    }
    {
        PyObject *tmp_assign_source_106;
        tmp_assign_source_106 = MAKE_FUNCTION_pylibpd$$$function_51_libpd_set_aftertouch_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_aftertouch_callback, tmp_assign_source_106 );
    }
    {
        PyObject *tmp_assign_source_107;
        PyObject *tmp_source_name_45;
        PyObject *tmp_mvar_value_49;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_49 == NULL ))
        {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_49 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 277;

            goto frame_exception_exit_1;
        }

        tmp_source_name_45 = tmp_mvar_value_49;
        tmp_assign_source_107 = LOOKUP_ATTRIBUTE( tmp_source_name_45, const_str_plain_libpd_set_aftertouch_callback );
        if ( tmp_assign_source_107 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 277;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_aftertouch_callback, tmp_assign_source_107 );
    }
    {
        PyObject *tmp_assign_source_108;
        tmp_assign_source_108 = MAKE_FUNCTION_pylibpd$$$function_52_libpd_set_polyaftertouch_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_polyaftertouch_callback, tmp_assign_source_108 );
    }
    {
        PyObject *tmp_assign_source_109;
        PyObject *tmp_source_name_46;
        PyObject *tmp_mvar_value_50;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_50 == NULL ))
        {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_50 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 281;

            goto frame_exception_exit_1;
        }

        tmp_source_name_46 = tmp_mvar_value_50;
        tmp_assign_source_109 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain_libpd_set_polyaftertouch_callback );
        if ( tmp_assign_source_109 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 281;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_polyaftertouch_callback, tmp_assign_source_109 );
    }
    {
        PyObject *tmp_assign_source_110;
        tmp_assign_source_110 = MAKE_FUNCTION_pylibpd$$$function_53_libpd_set_midibyte_callback(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_midibyte_callback, tmp_assign_source_110 );
    }
    {
        PyObject *tmp_assign_source_111;
        PyObject *tmp_source_name_47;
        PyObject *tmp_mvar_value_51;
        tmp_mvar_value_51 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain__pylibpd );

        if (unlikely( tmp_mvar_value_51 == NULL ))
        {
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pylibpd );
        }

        if ( tmp_mvar_value_51 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_pylibpd" );
            exception_tb = NULL;

            exception_lineno = 285;

            goto frame_exception_exit_1;
        }

        tmp_source_name_47 = tmp_mvar_value_51;
        tmp_assign_source_111 = LOOKUP_ATTRIBUTE( tmp_source_name_47, const_str_plain_libpd_set_midibyte_callback );
        if ( tmp_assign_source_111 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 285;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_set_midibyte_callback, tmp_assign_source_111 );
    }
    {
        PyObject *tmp_assign_source_112;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        tmp_name_name_5 = const_str_plain_array;
        tmp_globals_name_5 = (PyObject *)moduledict_pylibpd;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = Py_None;
        frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 287;
        tmp_assign_source_112 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
        assert( !(tmp_assign_source_112 == NULL) );
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_array, tmp_assign_source_112 );
    }
    {
        PyObject *tmp_assign_source_113;
        tmp_assign_source_113 = MAKE_FUNCTION_pylibpd$$$function_54___process_args(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___process_args, tmp_assign_source_113 );
    }
    {
        PyObject *tmp_assign_source_114;
        tmp_assign_source_114 = MAKE_FUNCTION_pylibpd$$$function_55_libpd_list(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_list, tmp_assign_source_114 );
    }
    {
        PyObject *tmp_assign_source_115;
        tmp_assign_source_115 = MAKE_FUNCTION_pylibpd$$$function_56_libpd_message(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_message, tmp_assign_source_115 );
    }
    {
        PyObject *tmp_assign_source_116;
        tmp_assign_source_116 = PyDict_New();
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_patches, tmp_assign_source_116 );
    }
    {
        PyObject *tmp_assign_source_117;
        PyObject *tmp_defaults_2;
        tmp_defaults_2 = const_tuple_str_dot_tuple;
        Py_INCREF( tmp_defaults_2 );
        tmp_assign_source_117 = MAKE_FUNCTION_pylibpd$$$function_57_libpd_open_patch( tmp_defaults_2 );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_open_patch, tmp_assign_source_117 );
    }
    {
        PyObject *tmp_assign_source_118;
        tmp_assign_source_118 = MAKE_FUNCTION_pylibpd$$$function_58_libpd_close_patch(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_close_patch, tmp_assign_source_118 );
    }
    {
        PyObject *tmp_assign_source_119;
        tmp_assign_source_119 = PyDict_New();
        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___libpd_subscriptions, tmp_assign_source_119 );
    }
    {
        PyObject *tmp_assign_source_120;
        tmp_assign_source_120 = MAKE_FUNCTION_pylibpd$$$function_59_libpd_subscribe(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_subscribe, tmp_assign_source_120 );
    }
    {
        PyObject *tmp_assign_source_121;
        tmp_assign_source_121 = MAKE_FUNCTION_pylibpd$$$function_60_libpd_unsubscribe(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_unsubscribe, tmp_assign_source_121 );
    }
    {
        PyObject *tmp_assign_source_122;
        tmp_assign_source_122 = MAKE_FUNCTION_pylibpd$$$function_61_libpd_compute_audio(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_compute_audio, tmp_assign_source_122 );
    }
    {
        PyObject *tmp_assign_source_123;
        tmp_assign_source_123 = MAKE_FUNCTION_pylibpd$$$function_62_libpd_release(  );



        UPDATE_STRING_DICT1( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_libpd_release, tmp_assign_source_123 );
    }
    {
        PyObject *tmp_assign_source_124;
        {
            PyObject *tmp_assign_source_125;
            tmp_assign_source_125 = MAKE_FUNCTION_pylibpd$$$function_63___init__(  );



            assert( tmp_locals_pylibpd_342_key___init__ == NULL );
            tmp_locals_pylibpd_342_key___init__ = tmp_assign_source_125;
        }
        {
            PyObject *tmp_assign_source_126;
            tmp_assign_source_126 = MAKE_FUNCTION_pylibpd$$$function_64_process(  );



            assert( tmp_locals_pylibpd_342_key_process == NULL );
            tmp_locals_pylibpd_342_key_process = tmp_assign_source_126;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            tmp_dict_value_1 = const_str_plain_pylibpd;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_124 = _PyDict_NewPresized( 3 );
            tmp_res = PyDict_SetItem( tmp_assign_source_124, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_pylibpd_342_key___init__ );
            tmp_dict_value_2 = tmp_locals_pylibpd_342_key___init__;
            tmp_dict_key_2 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_124, tmp_dict_key_2, tmp_dict_value_2 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_pylibpd_342_key_process );
            tmp_dict_value_3 = tmp_locals_pylibpd_342_key_process;
            tmp_dict_key_3 = const_str_plain_process;
            tmp_res = PyDict_SetItem( tmp_assign_source_124, tmp_dict_key_3, tmp_dict_value_3 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_2;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( pylibpd );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_locals_pylibpd_342_key___init__ );
        Py_DECREF( tmp_locals_pylibpd_342_key___init__ );
        tmp_locals_pylibpd_342_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_pylibpd_342_key_process );
        Py_DECREF( tmp_locals_pylibpd_342_key_process );
        tmp_locals_pylibpd_342_key_process = NULL;

        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( pylibpd );
        return MOD_RETURN_VALUE( NULL );
        outline_result_1:;
        assert( tmp_class_creation_2__class_dict == NULL );
        tmp_class_creation_2__class_dict = tmp_assign_source_124;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_127;
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_1 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 342;

            goto try_except_handler_3;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_2 = tmp_class_creation_2__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_127 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_assign_source_127 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 342;

            goto try_except_handler_3;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        // Tried code:
        {
            PyObject *tmp_mvar_value_52;
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___metaclass__ );

            if (unlikely( tmp_mvar_value_52 == NULL ))
            {
                tmp_mvar_value_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___metaclass__ );
            }

            if ( tmp_mvar_value_52 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__metaclass__" );
                exception_tb = NULL;

                exception_lineno = 342;

                goto try_except_handler_4;
            }

            tmp_assign_source_127 = tmp_mvar_value_52;
            Py_INCREF( tmp_assign_source_127 );
            goto outline_result_2;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( pylibpd );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );
        tmp_assign_source_127 = (PyObject *)&PyClass_Type;
        Py_INCREF( tmp_assign_source_127 );
        goto outline_result_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( pylibpd );
        return MOD_RETURN_VALUE( NULL );
        outline_result_2:;
        condexpr_end_1:;
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_127;
    }
    {
        PyObject *tmp_assign_source_128;
        PyObject *tmp_called_name_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_called_name_3 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_1 = const_str_plain_PdManager;
        tmp_args_element_name_2 = const_tuple_empty;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_args_element_name_3 = tmp_class_creation_2__class_dict;
        frame_c874ce24acba0c1b5e4d06071c656789->m_frame.f_lineno = 342;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_128 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_128 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 342;

            goto try_except_handler_3;
        }
        assert( tmp_class_creation_2__class == NULL );
        tmp_class_creation_2__class = tmp_assign_source_128;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    // Restore frame exception if necessary.
#if 1
    RESTORE_FRAME_EXCEPTION( frame_c874ce24acba0c1b5e4d06071c656789 );
#endif
    popFrameStack();

    assertFrameObject( frame_c874ce24acba0c1b5e4d06071c656789 );

    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_c874ce24acba0c1b5e4d06071c656789 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c874ce24acba0c1b5e4d06071c656789, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c874ce24acba0c1b5e4d06071c656789->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c874ce24acba0c1b5e4d06071c656789, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_1:;
    {
        PyObject *tmp_assign_source_129;
        CHECK_OBJECT( tmp_class_creation_2__class );
        tmp_assign_source_129 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain_PdManager, tmp_assign_source_129 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;


#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_pylibpd, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_pylibpd );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
